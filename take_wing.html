<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head> <title>Take Wing: Building Ontologies with Tawny-OWL</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- fn-in,html --> 
<meta name="src" content="take_wing.tex"> 
<meta name="date" content="2018-04-30 15:29:00"> 
<link rel="stylesheet" type="text/css" href="take_wing.css"> 
<script src="./prism.js"></script> 
<script src="./prism-tawny.js"></script> 
<link rel="stylesheet" href="./prism-tawny.css"> 
</head><body 
>
   <div class="maketitle">
                                                                     

                                                                     
                                                                     

                                                                     
                                                                     

                                                                     

<h2 class="titleHead">Take Wing: Building Ontologies with Tawny-OWL</h2>
<div class="author" ><span 
class="cmr-12">Phillip Lord</span></div><br />
<div class="date" ><span 
class="cmr-12">April 30, 2018</span></div>
                                                                     

                                                                     
   </div>
                                                                     

                                                                     
   <h2 class="likechapterHead"><a 
 id="x1-1000"></a>Contents</h2> <div class="tableofcontents">
   <span class="chapterToc" >1 <a 
href="#x1-20001" id="QQ2-1-2">Introduction</a></span>
<br />   &#x00A0;<span class="sectionToc" >1.1 <a 
href="#x1-30001.1" id="QQ2-1-3">Status</a></span>
<br />   &#x00A0;<span class="sectionToc" >1.2 <a 
href="#x1-40001.2" id="QQ2-1-4">What is an Ontology</a></span>
<br />   &#x00A0;<span class="sectionToc" >1.3 <a 
href="#x1-50001.3" id="QQ2-1-5">Who this book is for</a></span>
<br />   <span class="chapterToc" >2 <a 
href="#x1-60002" id="QQ2-1-6">A Rapid Walk-Through</a></span>
<br />   &#x00A0;<span class="sectionToc" >2.1 <a 
href="#x1-70002.1" id="QQ2-1-7">A Taster</a></span>
<br />   &#x00A0;<span class="sectionToc" >2.2 <a 
href="#x1-80002.2" id="QQ2-1-8">Environment</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.1 <a 
href="#x1-90002.2.1" id="QQ2-1-9">The OWL API</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.2 <a 
href="#x1-100002.2.2" id="QQ2-1-10">Clojure</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.3 <a 
href="#x1-110002.2.3" id="QQ2-1-11">Leiningen</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.4 <a 
href="#x1-120002.2.4" id="QQ2-1-12">REPL</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.5 <a 
href="#x1-130002.2.5" id="QQ2-1-13">IDE or Editor</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.6 <a 
href="#x1-140002.2.6" id="QQ2-1-14">Testing</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.7 <a 
href="#x1-150002.2.7" id="QQ2-1-15">Version Control and Collaboration</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >2.2.8 <a 
href="#x1-160002.2.8" id="QQ2-1-16">Continuous Integration</a></span>
<br />   &#x00A0;<span class="sectionToc" >2.3 <a 
href="#x1-170002.3" id="QQ2-1-17">Recap</a></span>
<br />   <span class="chapterToc" >3 <a 
href="#x1-180003" id="QQ2-1-18">An Introduction to OWL</a></span>
<br />   &#x00A0;<span class="sectionToc" >3.1 <a 
href="#x1-190003.1" id="QQ2-1-19">Individuals</a></span>
<br />   &#x00A0;<span class="sectionToc" >3.2 <a 
href="#x1-200003.2" id="QQ2-1-20">Properties</a></span>
<br />   &#x00A0;<span class="sectionToc" >3.3 <a 
href="#x1-210003.3" id="QQ2-1-21">Classes</a></span>
<br />   &#x00A0;<span class="sectionToc" >3.4 <a 
href="#x1-220003.4" id="QQ2-1-22">Identifiers</a></span>
<br />   &#x00A0;<span class="sectionToc" >3.5 <a 
href="#x1-230003.5" id="QQ2-1-23">Annotations</a></span>
<br />   <span class="chapterToc" >4 <a 
href="#x1-240004" id="QQ2-1-24">Getting Started</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >4.0.1 <a 
href="#x1-250004.0.1" id="QQ2-1-25">Installing Leiningen</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >4.0.2 <a 
href="#x1-260004.0.2" id="QQ2-1-26">Creating a New Project</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >4.0.3 <a 
href="#x1-270004.0.3" id="QQ2-1-27">Editing Our Ontology</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >4.0.4 <a 
href="#x1-280004.0.4" id="QQ2-1-31">Summary</a></span>
<br />   <span class="chapterToc" >5 <a 
href="#x1-290005" id="QQ2-1-32">The Pizza Ontology</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.1 <a 
href="#x1-300005.1" id="QQ2-1-33">Introduction</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.2 <a 
href="#x1-310005.2" id="QQ2-1-34">Creating the Skeleton</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.3 <a 
href="#x1-320005.3" id="QQ2-1-35">Preamble</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.4 <a 
href="#x1-330005.4" id="QQ2-1-36">Defining Classes</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.5 <a 
href="#x1-340005.5" id="QQ2-1-39">Properties</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.6 <a 
href="#x1-350005.6" id="QQ2-1-40">Populating the Ontology</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.7 <a 
href="#x1-360005.7" id="QQ2-1-41">Describing a Pizza</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.8 <a 
href="#x1-370005.8" id="QQ2-1-42">A simple pattern</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.9 <a 
href="#x1-380005.9" id="QQ2-1-43">Defined Classes</a></span>
<br />   &#x00A0;<span class="sectionToc" >5.10 <a 
href="#x1-390005.10" id="QQ2-1-44">Recap</a></span>
<br />   <span class="chapterToc" >6 <a 
href="#x1-400006" id="QQ2-1-45">Highly Patterned Ontologies</a></span>
<br />   &#x00A0;<span class="sectionToc" >6.1 <a 
href="#x1-410006.1" id="QQ2-1-46">Dealing with Patterns</a></span>
<br />   &#x00A0;<span class="sectionToc" >6.2 <a 
href="#x1-420006.2" id="QQ2-1-47">Creating the Amino Acid Ontology</a></span>
<br />   &#x00A0;<span class="sectionToc" >6.3 <a 
href="#x1-430006.3" id="QQ2-1-48">Defining the Amino Acids</a></span>
<br />   &#x00A0;<span class="sectionToc" >6.4 <a 
href="#x1-440006.4" id="QQ2-1-49">Recap</a></span>
<br />   <span class="chapterToc" >7 <a 
href="#x1-450007" id="QQ2-1-50">More on Pizza</a></span>
<br />   &#x00A0;<span class="sectionToc" >7.1 <a 
href="#x1-460007.1" id="QQ2-1-51">Recap</a></span>
<br />   <span class="chapterToc" >8 <a 
href="#x1-470008" id="QQ2-1-52">Keeping it in the Family</a></span>
<br />   &#x00A0;&#x00A0;<span class="subsectionToc" >8.0.1 <a 
href="#x1-480008.0.1" id="QQ2-1-53">Introduction</a></span>
<br />   &#x00A0;<span class="sectionToc" >8.1 <a 
href="#x1-490008.1" id="QQ2-1-54">The Ontology</a></span>
<br />   &#x00A0;<span class="sectionToc" >8.2 <a 
href="#x1-500008.2" id="QQ2-1-55">Recap</a></span>
<br />   <span class="chapterToc" >9 <a 
href="#x1-510009" id="QQ2-1-56">Conclusions</a></span>
   </div>
                                                                     

                                                                     
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;1</span><br /><a 
 id="x1-20001"></a>Introduction</h2>
<!--l. 4--><p class="noindent" >This book introduces ontology building using the OWL2 ontology language, and
the Tawny-OWL library. Ontologies are a method for representing knowledge,
generally, but not necessarily, about the world around us. It is then possible to
check that the representation is consistent, as well as drawing conclusions about
new knowledge. They are generally used in complex, knowledge-rich areas of
knowledge, including biomedicine.
<!--l. 11--><p class="indent" >   Many ontology development tools provide a Graphical User Interface, through
which the ontology developer adds the various entities involved in building an
ontology. However, many ontologies contain large and repetitive sections; for
these, ontology development teams often fall back to generating parts of their
ontology programmatically. Tawny-OWL takes a different approach where
ontology development uses a domain-specific language (DSL) embedded in a full
programming language. For structurally simple parts of an ontology, the various
components of an ontology can be specified using the default convienient and
simple Tawny-OWL syntax; for structurally complex parts, new syntax and new
patterns can be built, extending the environment as a core part of ontology
development.
<!--l. 24--><p class="indent" >   This form of programmatic ontology development is still young. At the
moment, we have used it to produce large ontologies that would have been
difficult using any other technique. However, we also hope that we can also
support easier integration of knowledge-rich structures into applications, so that
ontological data structures can be come a standard part of the programmers
toolkit.
   <h3 class="sectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-30001.1"></a>Status</h3>
<!--l. 35--><p class="noindent" >This manual describes Tawny-OWL 2.0. While more Chapters are planned, it
now describes all the key features of this Tawny-OWL environment.
<!--l. 38--><p class="indent" >   It is hosted at <a 
href="https://phillord.github.io/take-wing/" class="url" ><span 
class="cmtt-10x-x-109">https://phillord.github.io/take-_wing/</span></a>.
<!--l. 42--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-40001.2"></a>What is an Ontology</h3>
<!--l. 45--><p class="noindent" >Ontologies are about definitions. It is, perhaps, unsurprising therefore that
amount ontologists there are quite a few debates about what exactly an
ontology is and is not; it is not our intention here to either cover these
arguments, nor to give a comprehensive overview of all the uses of the
word.
<!--l. 51--><p class="indent" >   What is generally agreed is that ontologies describe a set of entities, in terms
of the relationships between these entities, using any of a number of different
relationships. So, for example, we can describe entities in terms of their class
relationships &#8211; what is true of a superclass is also true of all subclasses. Or we
can describe the <span 
class="cmti-10x-x-109">partonomic </span>relationships: the finger is part of the hand, which is
part of the foot.
<!--l. 59--><p class="indent" >   An ontology is also very similar to a taxonomy; however, ontologies place
much greater emphasis on their computational properties. This makes ontologies
much more suitable for driving applications and code, although this often comes
at the cost of human understandability of the ontology. In this document, all the
ontologies we talk about are represented using specific language, called OWL
(the Ontology Web Language). This has very well-defined computational
properties, and through the document we will explore the implications of these
properties.
<!--l. 69--><p class="indent" >   We also use the term &#8220;ontology&#8221; to mean a specific object that you can
manipulate in Tawny-OWL, which is a slightly more constrained use. This is
quite common in many books on programming: we hope that the context should
be clear.
<!--l. 74--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">1.3   </span> <a 
 id="x1-50001.3"></a>Who this book is for</h3>
<!--l. 77--><p class="noindent" >We have two primary audiences for this book. The first is for the ontologist who
is interested in Tawny-OWL as the hub of a new environment for ontology
development. The second is for the programmer who is interested in using the
rich computational representation of a domain that ontologies provide. There is a
risk to having two audiences: that we satisfy neither. To avoid this, the book is
built from a series of chapters, each of which covers a discrete topic, either more
programmatic or more ontological. It should be possible to read the chapters
independently of each other.
<!--l. 86--><p class="indent" >   This book does not, however, stand alone. While we try to introduce the
background material, we do not intend that, for example, this book will serve as
an introduction to programming either in general, or specifically in <a 
 id="dx1-5001"></a>Clojure.
There are many good resources available for this. With ontologies, we give more
of a background introduction, but again, we assume that you will be willing to
read other material to clarify ontology development. Our hope is that we
introduce the material well enough that you feel it is worth the time
to investigate other resources, and we include pointers where it seems
valuable.
                                                                     

                                                                     
                                                                     

                                                                     
                                                                     

                                                                     
<!--l. 2--><p class="indent" >
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;2</span><br /><a 
 id="x1-60002"></a>A Rapid Walk-Through</h2>
   <h3 class="sectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-70002.1"></a>A Taster</h3>
<!--l. 8--><p class="noindent" >We take a rapid walk-through an ontology to demonstrate the capabilities of
Tawny-OWL. As with all the examples in this book, the code in this
chapter is complete; it is possible to extract all the snippets from the
chapter, run them and retrieve a complete ontology. Therefore, we need
to start with a preamble, defining a namespace and performing some
imports.
<!--l. 15--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(ns take.wing.walk-through
  (:refer-clojure :only [])
  (:use [tawny.owl]
         [tawny.english]
         [tawny.reasoner]))
</code></pre>
<!--l. 23--><p class="indent" >   As we discussed in Section&#x00A0;<a 
href="#x1-40001.2">1.2<!--tex4ht:ref: sec:what_is_an_ontology --></a>, the word ontology has quite a few different
meanings, but here we use it to mean a specific computational object; so, before,
we do anything else, we start a new empty ontology, which we call <code class="language-tawny">walk_through</code>;
as it happens, we do not need to refer to this object again because it is now set
as the default for the rest of this chapter. We also take the opportunity to set our
choice of reasoner, in this case HermiT. We will see later how we use
this.
<!--l. 31--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defontology walk_through
  :iri "http://purl.org/ontolink/walk_through")

(reasoner-factory :hermit)
</code></pre>
<!--l. 38--><p class="indent" >   Ontologies are all about classes, so we now define two classes
one called <code class="language-tawny">Book</code> and one called <code class="language-tawny">TakeWing</code> which is a subclass of
<code class="language-tawny">Book</code>&#x00A0;<span class="footnote-mark"><a 
href="#fn1x3" id="fn1x3-bk"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-7001f1"></a>.
Anything that is true of <code class="language-tawny">Book</code> must also be true of <code class="language-tawny">TakeWing</code>.
<!--l. 52--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Book)

(defclass TakeWing
  :super Book)
</code></pre>
<!--l. 59--><p class="indent" >   Of course, this does not tell us much about <code class="language-tawny">TakeWing</code> as a book.
There are many properties of books, but one of the most informative
is the subject of the book. So, we define a new class of <code class="language-tawny">Subject</code>
and introduce a property <code class="language-tawny">about</code> which we use to relate books and
subjects&#x00A0;<span class="footnote-mark"><a 
href="#fn2x3" id="fn2x3-bk"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-7002f2"></a>.
<!--l. 66--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Subject)

(defoproperty about)
</code></pre>
<!--l. 72--><p class="indent" >   Now, we need some subject listings. Of course, there are many of these in
existence already, and Tawny-OWL is fully capable of reusing one of these;
however, for this simple example, it is not necessary, so we define a small
classification of our own. We describe <code class="language-tawny">Bird</code> and <code class="language-tawny">Ontology</code> as subclasses of <code class="language-tawny">Subject</code>
and say that they are different (<code class="language-tawny">:disjoint</code>) and do not overlap. We also describe
<code class="language-tawny">TawnyOWL</code> as part of the <code class="language-tawny">Ontology</code> subject.
<!--l. 79--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 Subject
 :disjoint
 (defclass Bird)
 (defclass Ontology))

(defclass TawnyOWL
  :super Ontology)
</code></pre>
<!--l. 90--><p class="indent" >   We can now make some basic queries against the statements that we have
made to make sure that they all make sense. So, for example, the <code class="language-tawny">subclasses</code>
function lists all of the subclasses of <code class="language-tawny">Book</code>, or we can use the predicate
function <code class="language-tawny">subclass?</code>. On its own this functionality is enough to build a simple
hierarchy.
<!--l. 96--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(subclasses Book)
;; =&gt; #{#[Class 0x660b9d1 "TakeWing"@en]}
(subclass? Book TakeWing)
;;=&gt; true
(subclass? Subject TawnyOWL)
;;=&gt; true
</code></pre>
<!--l. 105--><p class="indent" >   However, the functionality of OWL allows much richer statements than this.
We can extend the existing definition of <code class="language-tawny">TakeWing</code> and state that it is a book that
is about <code class="language-tawny">TawnyOWL</code> and only about <code class="language-tawny">TawnyOWL</code>.
<!--l. 109--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(class
 TakeWing
 :super
 (some-only about TawnyOWL))
</code></pre>
<!--l. 116--><p class="indent" >   Now, we can build some <span 
class="cmti-10x-x-109">defined </span>classes. We describe an <code class="language-tawny">OntologyBook</code> as a
<code class="language-tawny">Book</code> which is about <code class="language-tawny">Ontology</code>.
<!--l. 119--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass
 OntologyBook
 :equivalent
 (and Book
       (some about Ontology)))
</code></pre>
<!--l. 127--><p class="indent" >   There are two critical points about this definition. The first is that we had
said nothing at all about the relationship between this class and <code class="language-tawny">TakeWing</code>. We
can confirm this by asking about the <code class="language-tawny">subclasses</code> of <code class="language-tawny">OntologyBook</code>, and showing
that our ontology knows of no ontology books.
<!--l. 132--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(subclasses OntologyBook)
;;=&gt; #{}
</code></pre>
<!--l. 137--><p class="indent" >   However, this is not quite true. The second critical part of the definition, the
use of <code class="language-tawny">:equivalent</code>. This allows us to use <span 
class="cmti-10x-x-109">reasoning </span>to infer other subclasses. For
this we use the <code class="language-tawny">isubclasses</code> method instead and find that <code class="language-tawny">TakeWing</code> can be
infered to be an <code class="language-tawny">OntologyBook</code>.
<!--l. 142--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(isubclasses OntologyBook)
;; =&gt; #{#[Class 0x557ef049 "TakeWing"@en]}
</code></pre>
<!--l. 147--><p class="indent" >   We can infer that <code class="language-tawny">TakeWing</code> is a subclass of <code class="language-tawny">OntologyBook</code> because we
have said that an ontology book is one about ontologies and that this
book is about Tawny-OWL which is sub-topic of ontologies. Even in this
simple example, we need to put together a number of facts to draw this
conclusion.
<!--l. 152--><p class="indent" >   In this case, though, there is some apparent similarity between the definition
of <code class="language-tawny">OntologyBook</code> and <code class="language-tawny">TakeWing</code> &#8211; both of them are look relatively similar,
at least once we substitute <code class="language-tawny">Ontology</code> for <code class="language-tawny">TawnyOWL</code> in the definition of
<code class="language-tawny">TakeWing</code>. Our computational reasoner, however, does not work in this
way, and can draw conclusions even when this similarity does not exist.
Consider this example where we describe books which are not about
birds.
<!--l. 159--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass NonBirdBook
  :equivalent
  (and Book
        (not (some about Bird))))

(subclasses NonBirdBook)
;;=&gt; #{}

(isubclasses NonBirdBook)
;; =&gt; #{#[Class 0x557ef049 "TakeWing"@en]}
</code></pre>
<!--l. 172--><p class="indent" >   Here too, we can classify <code class="language-tawny">TakeWing</code>. The chain of logic in this case is that
<code class="language-tawny">TakeWing</code> is about <code class="language-tawny">Ontology</code>, that <code class="language-tawny">Ontology</code> is different from <code class="language-tawny">Bird</code>, and that,
therefore, <code class="language-tawny">TakeWing</code> is not about <code class="language-tawny">Bird</code> which makes it a <code class="language-tawny">NonBirdBook</code>.
<!--l. 176--><p class="indent" >   This ability to infer new knowledge is the meat and drink of computational
ontologies. They allow a rich description of the environment with a tightly
defined semantics which makes that environment comptutationally accessible.
Here, we have only touched on the expressivity of OWL &#8211; there are many
constructs that we have not shown yet. We have also used this for only for a
small ontology, but as the ontologies grow larger, the value increases.
<!--l. 183--><p class="indent" >   For existing ontology developers, this will be familiar ground. Tawny-OWL,
however, brings something new to other mechanisms for developing ontologies;
that is a fully programmatic environment. As well as the ability to automate any
part of ontology development that we choose, this also brings a rich set of
highly-developed tools that programmers have been developing and using for
many years to develop software in a repeatable, scalable and highly-collaborative
way. It is this which we explore next.
   <h3 class="sectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-80002.2"></a>Environment</h3>
<!--l. 195--><p class="noindent" >Tawny-OWL takes a different approach to other ontology development
environments. It is not an application, it is just a programmatic
library<span class="footnote-mark"><a 
href="#fn3x3" id="fn3x3-bk"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-8001f3"></a>.
This has a key advantage over a more traditional ontology editor; rather than
providing a complete environment, Tawny-OWL just recasts ontology
development as a form of software development and borrows its entire
environment from software development. This means we can reuse the software
engineering environment; our experience is that the richness and maturity of
software development tools far outweights any loss of specificity to ontology
development.
<!--l. 209--><p class="indent" >   Our hope is that for structurally simple ontologies, Tawny-OWL should be
usable by non-programmers, with a simple and straight-forward syntax. In this
section, we introduce the core technology and the basic environment that is
needed to make effective use of Tawny-OWL, as well as some optional
extras.
<!--l. 215--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2.1   </span> <a 
 id="x1-90002.2.1"></a>The OWL API</h4>
<!--l. 218--><p class="noindent" >Tawny-OWL is built using the <a 
href="http://owlapi.sourceforge.net/[OWL" class="url" ><span 
class="cmtt-10x-x-109">http://owlapi.sourceforge.net/[OWL</span></a> API].
This library is a comprehensive tool for generating, transforming and using OWL
Ontologies. It is widely used, and is the basis for the Protege 4 editor<span class="cite">[<span 
class="cmbx-10x-x-109">?</span>]</span>. Being
based on this library, Tawny-OWL is reliable and standard-compliant (or at
least as reliable and standard-compliant as Protege!). It is also easy to
integrate directly with other tools written using the OWL API, include
Protege.
<!--l. 226--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2.2   </span> <a 
 id="x1-100002.2.2"></a>Clojure</h4>
<!--l. 229--><p class="noindent" >Tawny-OWL is a programmatic library build on top of the Clojure language.
Tawny-OWL takes many things from Clojure. These include:
     <ul class="itemize1">
     <li class="itemize">the basic syntax with parentheses and with <span 
class="cmtt-10x-x-109">:keywords</span>
     </li>
     <li class="itemize">the ability to effectively add new syntax
     </li>
     <li class="itemize">the ability to extend Tawny-OWL with patterns
     </li>
     <li class="itemize">integration with other data sources
     </li>
     <li class="itemize">the test environment
     </li>
     <li class="itemize">the build, dependency and deployment tools</li></ul>
<!--l. 241--><p class="indent" >   In addition, most of the tools and environment that Tawny-OWL use to
enable development were built for Clojure and are used directly with little or no
additions. These include:
     <ul class="itemize1">
     <li class="itemize">IDEs or editors used for writing Clojure
     </li>
     <li class="itemize">the leiningen build tool</li></ul>
<!--l. 250--><p class="indent" >   Tawny-OWL inherits a line-orientated syntax which means that it works well
with tools written for any programming language; most notable among these are
version control systems which enable highly collaborative working on
ontologies.
<!--l. 255--><p class="indent" >   Clojure is treated as a programmatic library &#8211; the user never starts or runs
Clojure, and there is no <span 
class="cmtt-10x-x-109">clojure </span>command. Rather confusingly, this role is
fulfilled by Leiningen, which is the next item on the list.
<!--l. 259--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2.3   </span> <a 
 id="x1-110002.2.3"></a>Leiningen</h4>
<!--l. 262--><p class="noindent" ><a 
href="http://www.leiningen.org" >Leiningen</a> is a tool for working with Clojure projects. Given a directory
structure, and some source code leiningen will perform many project tasks
including checking, testing, releasing and deploying the project. In addition
to these, it has two critical functions that every Tawny-OWL project
will use: first, it manages dependencies, which means it will download
both Tawny-OWL and Clojure; second, it starts a REPL which is the
principle means by which the user will directly or indirectly interact with
Tawny-OWL.
<!--l. 271--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2.4   </span> <a 
 id="x1-120002.2.4"></a>REPL</h4>
<!--l. 274--><p class="noindent" >Clojure provides a REPL &#8211; Read-Eval-Print-Loop. This is the same thing as a
shell, or command line. For instance, we can the following into a Clojure REPL,
and it will print the return value, or 2 in this case.
<!--l. 279--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">;; returns 2
(+ 1 1)
</code></pre>
<!--l. 284--><p class="indent" >   The most usual way to start a REPL is to use leiningen which then sets up
the appropriate libraries for the local project. For example, <span 
class="cmtt-10x-x-109">lein repl </span>in
the source code for this document, loads a REPL with Tawny-OWL
pre-loaded. In practice, most people use the REPL indirectly through their
IDE.
   <h4 class="subsectionHead"><span class="titlemark">2.2.5   </span> <a 
 id="x1-130002.2.5"></a>IDE or Editor</h4>
<!--l. 293--><p class="noindent" >Clojure is supported by a wide variety of editors, which in turn means that they
can be used for Tawny-OWL. The choice of an editor is a very personal one (I
use Emacs), but in practice any good editor will work.
<!--l. 297--><p class="indent" >   The editor has two main roles. Firstly, as the name suggests it provides a rich
environment for writing Tawny-OWL commands. Secondly, the IDE will start
and interact with a REPL for you. This allows you to add or remove new classes
and other entities to an ontology interactively. Tawny-OWL has been designed
to take advantage of an IDE environment; in most cases, for example,
auto-completion will happen for you.
<!--l. 304--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2.6   </span> <a 
 id="x1-140002.2.6"></a>Testing</h4>
<!--l. 307--><p class="noindent" >Tawny-OWL can use any of the testing enviroments that come with Clojure,
including <code class="language-tawny">clojure.test</code> which is the most basic environment provided with
Clojure. This integrates well with both leiningen or an IDE both of which will
run tests for you and report on test cases.
<!--l. 312--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2.7   </span> <a 
 id="x1-150002.2.7"></a>Version Control and Collaboration</h4>
<!--l. 315--><p class="noindent" >Most ontologies are developed by many people, so some form of collaboration
support is needed. In general, with Tawny-OWL we achieve this in the same way
that programmers do; rather than providing a collaborative environment where
multiple people can edit the environment at the same time, we use version
control where different developers use slightly different versions of the
ontology, and then merge them together at the end. This works well
with Tawny-OWL as it has an attractive, line-orientated syntax. The
various version control tools can scale easily to thousands of developers
which is well in excess of most ontology projects. For this purpose, we use
<code class="language-tawny">git</code>.
<!--l. 325--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2.8   </span> <a 
 id="x1-160002.2.8"></a>Continuous Integration</h4>
<!--l. 328--><p class="noindent" >An ontology can be <span 
class="cmti-10x-x-109">continuously integrated </span>with both other ontologies that it
depends on, and with the software environment which uses it. Unlike other
ontology continuous integration systems, Tawny-OWL is just a library &#8211; so
anything that works with Clojure (or more abstractly a Java Virtual Machine)
will also work with Tawny-OWL.
<!--l. 334--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-170002.3"></a>Recap</h3>
<!--l. 337--><p class="noindent" >In this Chapter, we have built a small basic ontology which non-the-less
shows the computational power of OWL ontologies, while surveying the
advantages that Tawny-OWL brings as a development environment for
ontologies.
                                                                     

                                                                     
                                                                     

                                                                     
                                                                     

                                                                     
<!--l. 1--><p class="indent" >
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;3</span><br /><a 
 id="x1-180003"></a>An Introduction to OWL</h2>
<!--l. 4--><p class="noindent" >In Section&#x00A0;<a 
href="#x1-40001.2">1.2<!--tex4ht:ref: sec:what_is_an_ontology --></a>, we briefly touched on the issue of what is an ontology and noted
that it&#8217;s not easy. In this section, we will take a more pragmatic view point and
describe OWL and its notion of an ontology.
<!--l. 9--><p class="indent" >   OWL2 is the second version of the Ontology Web Language; it is a W3C
recommendation<span class="footnote-mark"><a 
href="#fn1x4" id="fn1x4-bk"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-18001f1"></a>.
As you might expect, this means that it embeds well with other W3C standards
&#8211; it can be serialized as XML or RDF, and it makes quite intensive use of
URLs.
<!--l. 16--><p class="indent" >   It also builds on many years of Computing research; underneath each of the
statements that we can make in OWL is a mapping to a piece of formal maths which
gives a tightly defined <span 
class="cmti-10x-x-109">semantics</span>. We will only touch of this semantics lightly in this
document<span class="footnote-mark"><a 
href="#fn2x4" id="fn2x4-bk"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-18002f2"></a>;
the key point is that this specification makes it possible to build software around
OWL and have it come to a clearly defined conclusions.
<!--l. 24--><p class="indent" >   Using the statements in OWL we can build models of the world. That is we
can describe the real world around us using statements in OWL; as a result, we
can use these underlying semantics of OWL to draw conclusions about these
models. If we do this right, these conclusions should also be true of the real world
as well.
<!--l. 30--><p class="indent" >   There are a number of different ways that we could build models, but OWL
does this with three entities: individuals, classes and properties. In addition, to
enable OWL ontologies to describe the real world, it also has two further entities:
identifiers and annotations.
   <h3 class="sectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-190003.1"></a>Individuals</h3>
<!--l. 39--><p class="noindent" >At heart, OWL ontologies describe a set of individuals. In the real world, these
would be the things that we want to describe. Looking around me now, I can see
a large number of these things: a computer screen (obviously); a keyboard;
assorted other pieces of computing detritus; a guitar; a door; and, finally,
somewhat incongruously, a toilet seat. Individuals in OWL can also describe
more abstract things such as the image on my screen, the process of me typing
and so forth.
<!--l. 47--><p class="indent" >   Sometimes, individuals are also called instances; we do not use this term here,
because it causes confusion with people who come from an Object-Oriented
programming background where it has a related but subtly different
meaning<span class="footnote-mark"><a 
href="#fn3x4" id="fn3x4-bk"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-19001f3"></a>.
<!--l. 53--><p class="indent" >   In OWL ontologies, individuals also have a name or an
identifier<span class="footnote-mark"><a 
href="#fn4x4" id="fn4x4-bk"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-19002f4"></a>.
Actually, they can any number of names and, perhaps, unintuitively, OWL
will not assume that they have an unique name; so, unless you tell it
explicitly, OWL will not know whether two different identifiers describe two
different individuals with one name each, or one individual with two
names.
<!--l. 61--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-200003.2"></a>Properties</h3>
<!--l. 64--><p class="noindent" >Individuals can have relations between them. In OWL, these are called
properties<span class="footnote-mark"><a 
href="#fn5x4" id="fn5x4-bk"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-20001f5"></a>. So,
the <code class="language-tawny">I</code> am <code class="language-tawny">typing</code> on my <code class="language-tawny">Keyboard</code> which describes the relationship between two individuals.
In OWL properties are <span 
class="cmti-10x-x-109">binary </span>&#8211; that is they only describe a relationship between two
individuals<span class="footnote-mark"><a 
href="#fn6x4" id="fn6x4-bk"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-20002f6"></a>.
Properties in OWL have a number of characteristics, which we will describe
later.
<!--l. 73--><p class="indent" >   It is also possible to use properties to describe a relationship between
an individual and something <span 
class="cmti-10x-x-109">concrete </span>&#8211; such as a numeric value or a
string.
<!--l. 77--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.3   </span> <a 
 id="x1-210003.3"></a>Classes</h3>
<!--l. 80--><p class="noindent" >Classes in OWL are <span 
class="cmti-10x-x-109">sets </span>on individuals. All the individuals in a class will share
some of the same characteristics. Classes have relationships between themselves
which turn them into a hierarchy. So, both my <code class="language-tawny">Trackball</code>, <code class="language-tawny">Keyboard</code> and <code class="language-tawny">Monitor</code>
are subclasses of <code class="language-tawny">Peripherals</code>. In OWL, the meaning of the subclass relationship
is quite specific &#8211; if <code class="language-tawny">A</code> is a subclass of <code class="language-tawny">B</code>, then all individuals of class <code class="language-tawny">A</code> are also
individuals of class <code class="language-tawny">B</code>.
<!--l. 88--><p class="indent" >   For people coming from an programming background, this looks very like
object-orientation (OO) and its notion of instances, classes and subclasses. But
there is subtle, but important difference. In OO, instances are explicitly stated to
be part of a class, and inherit properties from this class. In OWL, it is the other
way around: individuals have properties, and then properties that they have
define the classes that they are in. We can see this in Section&#x00A0;<a 
href="#x1-70002.1">2.1<!--tex4ht:ref: sec:taster --></a>, where we can
<span 
class="cmti-10x-x-109">infer </span>that <code class="language-tawny">TakeWing</code> is an <code class="language-tawny">OntologyBook</code>.
<!--l. 98--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.4   </span> <a 
 id="x1-220003.4"></a>Identifiers</h3>
<!--l. 101--><p class="noindent" >To make all of the logical entities in OWL useful, we need <span 
class="cmti-10x-x-109">identifiers</span>
which allows us to refer to them. Again, most programming languages
have this sort of capability: variable names, class names and so forth.
OWL is rather different here and shows its web heritage; it uses IRIs for
identifiers<span class="footnote-mark"><a 
href="#fn7x4" id="fn7x4-bk"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-22001f7"></a>.
<!--l. 109--><p class="indent" >   Identifiers in OWL, therefore, are effectively universal; a class in one
ontology can unambiguously refer to a class in another. More over, it
can use and share identifiers described and defined in all the other web
technologies.
<!--l. 114--><p class="indent" >   Tawny-OWL maps these identifiers on to its own which inherits from its base
language of Clojure; this largely stems from the requirements for identifiers which
are easy to type and use.
<!--l. 119--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.5   </span> <a 
 id="x1-230003.5"></a>Annotations</h3>
<!--l. 122--><p class="noindent" >Those who are interested in the underlying semantics of OWL often describe
annotations are <span 
class="cmti-10x-x-109">extra-logically</span>. This rather downgrades their importance; it is
annotations that allow the underlying logic to relate to the real world around.
The underlying logic of OWL may provides predictable behaviour, but is the
annotations which provide all the utility of an OWL ontology, by relating to the
real world and to the user.
<!--l. 130--><p class="indent" >   OWL allows annotations on pretty much anything. Classes, individuals and
properties can all have annotations; the axioms that assert these entities can have
annotations; annotations can have annotations; it is even possible to use
annotations to provide descriptions of why annotations have annotations. It is
entirely possible that the designers of OWL got a little carried away with
annotations, Tawny-OWL supports the many different forms of annotation
anyway.
                                                                     

                                                                     
                                                                     

                                                                     
                                                                     

                                                                     
<!--l. 1--><p class="indent" >
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;4</span><br /><a 
 id="x1-240004"></a>Getting Started</h2>
<!--l. 8--><p class="noindent" >In this section, we will build the most ontology and start to show the basic
capabilities of Tawny-OWL.
<!--l. 11--><p class="indent" >   As described in , Tawny-OWL can be used with several different toolchains.
In this section, we will run through the building a very simple ontology. There is
an section describing how to achieve each of these steps with specific tool
chains.
   <h4 class="subsectionHead"><span class="titlemark">4.0.1   </span> <a 
 id="x1-250004.0.1"></a>Installing Leiningen</h4>
<!--l. 19--><p class="noindent" >To build an ontology, we need a build tool, for which we will use <a 
href="https://leiningen.org" >leiningen</a>. This
is a command line application and is simple to install following the instructions
on their website.
<!--l. 24--><p class="indent" >   Installing leiningen is the only manual step involved. It is leiningen that is
responsible for everything else; it downloads Tawny-OWL and all of its
dependencies for you.
<!--l. 28--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.0.2   </span> <a 
 id="x1-260004.0.2"></a>Creating a New Project</h4>
<!--l. 31--><p class="noindent" >Now, we will create a new project. Tawny-OWL makes this easy with a
pre-defined template.
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-1">
lein&#x00A0;new&#x00A0;ontology&#x00A0;helloworld
</div>
<!--l. 36--><p class="nopar" >
<!--l. 38--><p class="indent" >   This will create a new directory called <code class="language-tawny">helloworld</code>. If we change into
this directory, we find that this has created a number of directories and
files.
<!--l. 42--><p class="indent" >   Before we look in more detail at these files, let start by generating an
ontology file. Simply type:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-2">
lein&#x00A0;run
</div>
<!--l. 47--><p class="nopar" >
<!--l. 49--><p class="indent" >   You should see that a new file has been created called <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10x-x-109">helloworld.omn</span></span></span> which
contains a very simple ontology with a single class called <code class="language-tawny">HelloWorld</code>.
<!--l. 53--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.0.3   </span> <a 
 id="x1-270004.0.3"></a>Editing Our Ontology</h4>
<!--l. 56--><p class="noindent" >Tawny-OWL provides a fully programmatic development environment for
ontologies; as such, it is possible to change or update an ontology with an editor
or any IDE. In this section, we will use a simple, web-based editor that integrates
tightly with leiningen.
<!--l. 61--><p class="indent" >   To use this try:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-3">
lein&#x00A0;with-profile&#x00A0;light&#x00A0;nightlight
</div>
<!--l. 65--><p class="nopar" >
<!--l. 67--><p class="indent" >   This should return something like:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-4">
Started&#x00A0;Nightlight&#x00A0;on&#x00A0;http://localhost:4000
</div>
<!--l. 71--><p class="nopar" >
<!--l. 73--><p class="indent" >   Open this address in a web-browser and you should now be able to see the
editor, as see in Figure<a 
href="#x1-270011">4.1<!--tex4ht:ref: fig:nightlight --></a>.
<!--l. 76--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                     

                                                                     
<a 
 id="x1-270011"></a>
                                                                     

                                                                     

<!--l. 78--><p class="noindent" ><img 
src="images/night-instarepl.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.1: </span><span  
class="content">HelloWorld in nightlight</span></div><!--tex4ht:label?: x1-270011 -->
                                                                     

                                                                     
<!--l. 81--><p class="indent" >   </div><hr class="endfigure">
<!--l. 83--><p class="indent" >   First, we consider the file <code class="language-tawny">helloworld.clj</code>; this looks like so:
   <!--l. 85--><div class="lstinputlisting">
<a 
 id="x1-27002"></a>
   <span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27003r1"></a></span><span 
class="cmtt-10">(</span><span 
class="cmtt-10">ns</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27004r2"></a></span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">(</span><span 
class="cmtt-10">:use</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">[</span><span 
class="cmtt-10">tawny</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">owl</span><span 
class="cmtt-10">]))</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27005r3"></a></span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27006r4"></a></span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27007r5"></a></span><span 
class="cmtt-10">(</span><span 
class="cmtt-10">defontology</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27008r6"></a></span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">:iri</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">"</span><span 
class="cmtt-10">http:</span><span 
class="cmtt-10">//</span><span 
class="cmtt-10">example</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">com</span><span 
class="cmtt-10">/</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">"</span><span 
class="cmtt-10">)</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27009r7"></a></span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27010r8"></a></span><span 
class="cmtt-10">(</span><span 
class="cmtt-10">defclass</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">HelloWorld</span><span 
class="cmtt-10">)</span>
   
   </div>
<!--l. 87--><p class="indent" >   Breaking this down. We first start with by introducing the namespace and
<code class="language-tawny">use</code>ing Tawny-OWL. These identical statements appear at the beginning of
every Tawny-OWL file: the namespace introduced must match the file
name.
<!--l. 92--><p class="indent" >   Next, we create a new ontology called <code class="language-tawny">helloworld</code>, with a single class also
called (somewhat repetitively), <code class="language-tawny">HelloWorld</code>. Tawny-OWL is case-sensitive, so
these two things are independent from each other.
<!--l. 96--><p class="indent" >   The second file, <code class="language-tawny">core.clj</code> is more programmatic in nature. It <code class="language-tawny">require</code>s
<code class="language-tawny">helloworld</code>, and then defines a function called <code class="language-tawny">-main</code> which saves the
ontology.
   <!--l. 100--><div class="lstinputlisting">
<a 
 id="x1-27011"></a>
   <span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27012r1"></a></span><span 
class="cmtt-10">(</span><span 
class="cmtt-10">ns</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">core</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27013r2"></a></span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">[</span><span 
class="cmtt-10">:use</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">[</span><span 
class="cmtt-10">tawny</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">owl</span><span 
class="cmtt-10">]]</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27014r3"></a></span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">[</span><span 
class="cmtt-10">:require</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">[</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">]])</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27015r4"></a></span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27016r5"></a></span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27017r6"></a></span><span 
class="cmtt-10">(</span><span 
class="cmtt-10">defn</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">-main</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">[</span><span 
class="cmtt-10">&amp;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">args</span><span 
class="cmtt-10">]</span><span 
class="cmtt-10">&#x00A0;</span><br /><span class="label"><a 
 id="x1-27018r7"></a></span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">(</span><span 
class="cmtt-10">save-ontology</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">/</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">"</span><span 
class="cmtt-10">helloworld</span><span 
class="cmtt-10">.</span><span 
class="cmtt-10">omn</span><span 
class="cmtt-10">"</span><span 
class="cmtt-10">))</span>
   
   </div>
<!--l. 102--><p class="indent" >   The practical upshot of this all taken together is that typing
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-5">
lein&#x00A0;run
</div>
<!--l. 106--><p class="nopar" >
<!--l. 108--><p class="indent" >   at the command line will result in a new file (called <code class="language-tawny">helloworld.omn</code>) with an
ontology in OWL Manchester Notation (OMN).
   <h4 class="subsectionHead"><span class="titlemark">4.0.4   </span> <a 
 id="x1-280004.0.4"></a>Summary</h4>
<!--l. 114--><p class="noindent" >In this section, we have outlined the basic tasks that are needed to build
ontologies with Tawny-OWL: creating a project, creating an ontology,
creating some entities. We have also started to show how to use and query
over them. In the next section, we will build this ontology in full, using
it to demonstrate many parts of Tawny-OWL and OWL ontologies in
general.
                                                                     

                                                                     
                                                                     

                                                                     
                                                                     

                                                                     
<!--l. 1--><p class="indent" >
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;5</span><br /><a 
 id="x1-290005"></a>The Pizza Ontology</h2>
   <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x1-300005.1"></a>Introduction</h3>
<!--l. 7--><p class="noindent" >In this section, we will create a Pizza ontology; we choose pizzas because they are
simple, well-understood and compositional (see <a 
href="http://robertdavidstevens.wordpress.com/2010/01/22/why-the-pizza-ontology-tutorial/" >here</a> for more).
<!--l. 12--><p class="indent" >   As we described in a previous Chapter&#x00A0;<a 
href="#x1-180003">3<!--tex4ht:ref: cha:an-introduction-owl --></a>, we consider the different
types of entities present in an OWL ontology. The most (and least!)
important of these are <span 
class="cmti-10x-x-109">individuals</span>. We say that these are the most important
because it is these individuals that are described and constrained by
the other objects. We say that they are the least important because, in
practice, many ontologies do not explicitly describe any individuals at
all.
<!--l. 21--><p class="indent" >   If this seems perverse, consider a menu in a pizza shop. We might see an item
saying &#8221;Margherita&hellip; 5.50&#8221;. The menu makes no statements at all about an
individual pizza. It is saying that any margherita pizza produced in this resturant
is going to (or already has) cost 5.50. From the menu, we have no idea how many
margherita pizzas have been produced or have been consumed. But, menu is still
useful. The menu is comprehensive, tells you something about all the pizzas that
exist (at least in one resturant) and the different types of pizza. This is different
to the bill, which describes individuals &#8211; the pizzas that have actually been
provided, how many pizza and how much they all cost. In ontological
terms, the menu describes the <span 
class="cmbx-10x-x-109">classes</span>, the bill describes <span 
class="cmbx-10x-x-109">individuals</span>
<span class="footnote-mark"><a 
href="#fn1x6" id="fn1x6-bk"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-30001f1"></a>.
OWL Ontologies built with Tawny-OWL <span 
class="cmti-10x-x-109">can </span>describe either or both of these
entities but in most cases focus on classes.
<!--l. 40--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.2   </span> <a 
 id="x1-310005.2"></a>Creating the Skeleton</h3>
<!--l. 42--><p class="noindent" >As we discussed in Section&#x00A0;<a 
href="#x1-260004.0.2">4.0.2<!--tex4ht:ref: sec:creating-new-project --></a>, it is possible to use leiningen to create a new
ontology project. We will do this now:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-6">
lein&#x00A0;new&#x00A0;ontology&#x00A0;take-wing-pizza
</div>
<!--l. 48--><p class="nopar" >
<!--l. 50--><p class="indent" >   This will create a directory called
<code class="language-tawny">take-wing-pizza</code><span class="footnote-mark"><a 
href="#fn2x6" id="fn2x6-bk"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-31001f2"></a>.
We can now edit the files in this directory, starting with <code class="language-tawny">take/wing/pizza.clj</code>
using either nightlight as described in Section&#x00A0;<a 
href="#x1-270004.0.3">4.0.3<!--tex4ht:ref: sec:editing-our-ontology --></a>, or any other IDE.
<!--l. 57--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.3   </span> <a 
 id="x1-320005.3"></a>Preamble</h3>
<!--l. 60--><p class="noindent" >In Chapter&#x00A0;<a 
href="#x1-60002">2<!--tex4ht:ref: cha:rapid-walk-through --></a>, we showed the standard template for a Tawny-OWL file; and
indeed, leiningen has created a pizza themed version for us.
<!--l. 64--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(ns take.wing.pizza
  (:require [tawny.owl :refer :all]))
</code></pre>
<!--l. 69--><p class="indent" >   It is not absolutely critial to understand these statements, but they are
simple enough and worth explaining now, even though they will become much
more relevant and start to exploit the underlying programming language of
Tawny-OWL, that is Clojure.
<!--l. 74--><p class="indent" >   Statements in Clojure are also known as &#8220;forms&#8221;. Pretty much all Clojure
forms have the same structure; that is they are delimited by <code class="language-tawny">(</code> and <code class="language-tawny">)</code>. Forms
are usually named after the first letters that appear in them, which is
the name of the function they will call; so in this case, we have a <code class="language-tawny">ns</code> or
&#8220;namespace&#8221; form. Forms can be nested. The <code class="language-tawny">:require</code> form is an example of
this. In this case, the <code class="language-tawny">:require</code> says simply to make the Tawny-OWL
functions available for use. The colon in <code class="language-tawny">:require</code> means that this is a
<span 
class="cmti-10x-x-109">keyword</span>. Tawny-OWL uses these in many places to define parameters,
as we see next. Before we go any further, let&#8217;s make this slightly more
complex:
<!--l. 86--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(ns take.wing.pizza
  (:require [tawny.owl :refer :all]
             [tawny.reasoner :as r]))
</code></pre>
<!--l. 92--><p class="indent" >   We will see the importance of <code class="language-tawny">tawny.reasoner</code> later. Next, we have a
<code class="language-tawny">defontology</code> form which looks like this:
<!--l. 95--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defontology take-wing-pizza
  :iri "http://example.com/take-wing-pizza")
</code></pre>
<!--l. 100--><p class="indent" >   The name of the function <code class="language-tawny">defontology</code> tells us something useful; as well
as creating an ontology, we are defining a name which we can use to
refer to the ontology. The name is <code class="language-tawny">take-wing-pizza</code> which comes next.
Finally, we define some parameters &#8211; in this case, the IRI. All OWL
ontologies require IRIs (strictly the Ontology IRI) by which they can be
refered<span class="footnote-mark"><a 
href="#fn3x6" id="fn3x6-bk"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-32001f3"></a>.
Here, we invent one in the <code class="language-tawny">example.com</code> domain. You should change this to an IRI
you control. In this case, we use one from <code class="language-tawny">purl.org</code>.
<!--l. 112--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defontology take-wing-pizza
  :iri "http://purl.org/ontolink/take-wing/pizza")
</code></pre>
<!--l. 117--><p class="indent" >   The semantics of this statement are quite interesting. If we had created a new
database, by default, the database would be considered to be empty &#8211; that is
there would be no individuals in it. With an ontology, the opposite is true. By
default, we assume that there could be any number of individuals. As of yet, we
just have not said anything about these individuals.
   <h3 class="sectionHead"><span class="titlemark">5.4   </span> <a 
 id="x1-330005.4"></a>Defining Classes</h3>
<!--l. 127--><p class="noindent" >Next, we declare two classes. A class is a set of individuals with shared
characteristics. The basic template creates an entirely useless <code class="language-tawny">HelloWorld</code> task for
us like so:
<!--l. 131--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass HelloWorld)
</code></pre>
<!--l. 135--><p class="indent" >   This follows the same syntax as all forms with <code class="language-tawny">(</code> and <code class="language-tawny">)</code>, and follows the
convention of <code class="language-tawny">defontology</code> &#8211; a class object is created as well as a name
<code class="language-tawny">HelloWorld</code> which we can use to refer to that object. In this case, we do not add
any arguments nor do we need to. If you are using nightlight, it should look like
this:
<!--l. 141--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                     

                                                                     
<a 
 id="x1-330011"></a>
                                                                     

                                                                     

<!--l. 143--><p class="noindent" ><img 
src="images/night-pizza.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.1: </span><span  
class="content">A new pizza ontology</span></div><!--tex4ht:label?: x1-330011 -->
                                                                     

                                                                     
<!--l. 146--><p class="indent" >   </div><hr class="endfigure">
<!--l. 148--><p class="indent" >   It is possible to run, or evaluate, Tawny-OWL files as well. To see this in
nightlight, simply select &#8220;Insta-REPL&#8221; on the top-right.
<!--l. 151--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                     

                                                                     
<a 
 id="x1-330022"></a>
                                                                     

                                                                     

<!--l. 153--><p class="noindent" ><img 
src="images/night-instarepl.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.2: </span><span  
class="content">The Insta-REPL</span></div><!--tex4ht:label?: x1-330022 -->
                                                                     

                                                                     
<!--l. 156--><p class="indent" >   </div><hr class="endfigure">
<!--l. 158--><p class="indent" >   On the left, we can see the results of this evaluation. The actual values are
not that useful in Tawny-OWL, but the that they are green shows that they are
valid.
<!--l. 162--><p class="indent" >   Clearly, as this is supposed to be an ontology of pizza rather than classic
computer programs, we will need to change this. So, first we replace
<code class="language-tawny">HelloWorld</code> with <code class="language-tawny">Pizza</code> and add a new class called <code class="language-tawny">PizzaComponent</code>. As
with our <code class="language-tawny">defontology</code> form, have a <code class="language-tawny">def</code> form; however, in this case, we
do not use any arguments. The semantics of these two statements are
that, there is a class called <code class="language-tawny">Pizza</code> and another called <code class="language-tawny">PizzaComponent</code>
which individuals may be members of. However, we know nothing at all
about the relationship between an individual <code class="language-tawny">Pizza</code> and an individual
<code class="language-tawny">PizzaComponent</code><span class="footnote-mark"><a 
href="#fn4x6" id="fn4x6-bk"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-33003f4"></a>.
<!--l. 177--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Pizza)
(defclass PizzaComponent)
</code></pre>
<!--l. 182--><p class="indent" >   To build an accurate ontology, we may wish to describe this relationship
further. We might ask the question, can an individual be both a <code class="language-tawny">Pizza</code> and a
<code class="language-tawny">PizzaComponent</code> at the same time. The answer to this is no, but currently our
ontology does not state this. In OWL terminology, we wish to say that these
two classes are <span 
class="cmti-10x-x-109">disjoint</span>. We can achieve this by adding an <code class="language-tawny">as-disjoint</code>
statement.
<!--l. 189--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint Pizza PizzaComponent)
</code></pre>
<!--l. 193--><p class="indent" >   This works well, but is a little duplicative. If we add a new class which we
wish to also be disjoint, it must be added in two places. Instead, it is possible to
do both at once. This has the advantage of grouping the two classes together in
the file, as well as semantically, which should make the source more future-proof;
should we need new classes, we will automatically become disjoint as
required.
<!--l. 200--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint
 (defclass Pizza)
 (defclass PizzaComponent))
</code></pre>
<!--l. 206--><p class="indent" >   If you are using Nightlight, you may find it a little hard to edit your file to
achieve this as Nightlight uses <a 
href="http://shaunlebron.github.io/parinfer/" >parinfer</a>. This puts the parentheses in place for
you. To make this statement, type <code class="language-tawny">as-disjoint</code> before the other two
forms:
<!--l. 212--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint)
(defclass Pizza)
(defclass PizzaComponent)
</code></pre>
<!--l. 218--><p class="indent" >   Now, add two spaces in front of <code class="language-tawny">defclass&#x00A0;Pizza)</code> and then
<code class="language-tawny">(defclass&#x00A0;PizzaComponent)</code>. The parentheses should take care of themselves.
<!--l. 221--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint
 (defclass Pizza
   :label "Pizza"
   :comment "A type of prepared food, originating from Italy, consisting of a
flatbread with any of a large variety of other foods on top.")
 (defclass PizzaComponent
   :label "Pizza Component"
   :comment "Food that is part of a pizza."))
</code></pre>
<!--l. 232--><p class="indent" >   The semantics of these statements are that our ontology may have any
number of individuals, some of which may be <code class="language-tawny">Pizza</code>, some of which may be
<code class="language-tawny">PizzaComponent</code>, but none of which can be both <code class="language-tawny">Pizza</code> and <code class="language-tawny">PizzaComponent</code> at the
same time. Before we added the <code class="language-tawny">as-disjoints</code> statement, we would have assumed
that it was possible to be both. We also add to this two <span 
class="cmti-10x-x-109">annotations </span>that can be
used to provide more contextualized information about the pizza &#8211; in this case a
label and a comment.
<!--l. 241--><p class="indent" >   As well as describing that two classes are different, we may also wish
to describe that they are closely related, or that they are <span 
class="cmti-10x-x-109">subclasses</span>.
Where one class is a subclass of another, we are saying that everything
that is true of the superclass is also true of the subclass. Or, in terms of
individuals, that every individual of the subclass is also an individual of the
superclass.
<!--l. 248--><p class="indent" >   Next, we add two more classes, in this case classes for base and toppings. We
include the statement that they have <code class="language-tawny">PizzaComponent</code> as a superclass. We do this
by adding a <code class="language-tawny">:super</code> argument or <span 
class="cmti-10x-x-109">frame </span>to our <code class="language-tawny">defclass</code> statement.
<!--l. 253--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass PizzaBase
  :super PizzaComponent)
(defclass PizzaTopping
  :super PizzaComponent)
</code></pre>
<!--l. 260--><p class="indent" >   In Tawny-OWL, the frames can all be read in the same way. Read forwards,
we can say <code class="language-tawny">PizzaBase</code> has a superclass <code class="language-tawny">PizzaComponent</code>, or backwards
<code class="language-tawny">PizzaComponent</code> is a superclass of <code class="language-tawny">PizzaBase</code>. Earlier, we say the <code class="language-tawny">:iri</code> frame for
<code class="language-tawny">defontology</code> which is read similarly &#8211; <code class="language-tawny">pizza</code> has the given IRI.
<!--l. 266--><p class="indent" >   As every individual of, for example, <code class="language-tawny">PizzaBase</code> is <code class="language-tawny">PizzaComponent</code>, and no
<code class="language-tawny">PizzaComponent</code> individual can also be a <code class="language-tawny">Pizza</code> this also implies that no <code class="language-tawny">PizzaBase</code>
is a <code class="language-tawny">Pizza</code>. In otherwords, the disjointness is inherited.
<!--l. 270--><p class="indent" >   As with the disjoint statement, this is little long winded; we have to name the
<code class="language-tawny">PizzaComponent</code> superclass twice. Tawny-OWL provides a short cut for this, with
the <code class="language-tawny">as-subclasses</code> function.
<!--l. 274--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 PizzaComponent
 (defclass PizzaBase)
 (defclass PizzaTopping))
</code></pre>
<!--l. 281--><p class="indent" >   We are still not complete; we asked the question previously, can you be both
a <code class="language-tawny">Pizza</code> and a <code class="language-tawny">PizzaComponent</code>, to which the answer is no. We can apply the same
question, and get the same answer to a <code class="language-tawny">PizzaBase</code> and <code class="language-tawny">PizzaTopping</code>. These two,
therefore, should also be disjoint. However, we can make a stronger statement
still. The only kind of <code class="language-tawny">PizzaComponent</code> that there are either a <code class="language-tawny">PizzaBase</code> or a
<code class="language-tawny">PizzaTopping</code>. We say that the <code class="language-tawny">PizzaComponent</code> class is <span 
class="cmti-10x-x-109">covered </span>by its two
subclasses<span class="footnote-mark"><a 
href="#fn5x6" id="fn5x6-bk"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-33004f5"></a>.
We can add both of these statements to the ontology also.
<!--l. 295--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 PizzaComponent
 :disjoint :cover
 (defclass PizzaBase)
 (defclass PizzaTopping))
</code></pre>
<!--l. 303--><p class="indent" >   We now have the basic classes that we need to describe a pizza.
   <h3 class="sectionHead"><span class="titlemark">5.5   </span> <a 
 id="x1-340005.5"></a>Properties</h3>
<!--l. 308--><p class="noindent" >Now, we wish to describe more about <code class="language-tawny">Pizza</code>; in particular, we want to say more
about the relationship between <code class="language-tawny">Pizza</code> and two <code class="language-tawny">PizzaComponent</code> classes. OWL
provides a rich mechanism for describing relationships between individuals and,
in turn, how individuals of classes are related to each other. As well as there
being many different types of individuals, there can be many different types of
relationships. It is the relationships to other classes or individuals that allow us
to describe classes, and it is for this reason that the different types of
relationships are called <span 
class="cmti-10x-x-109">properties</span>.
<!--l. 317--><p class="indent" >   A <code class="language-tawny">Pizza</code> is built from one or more <code class="language-tawny">PizzaComponent</code> individuals; we first define two
properties <span class="footnote-mark"><a 
href="#fn6x6" id="fn6x6-bk"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-34001f6"></a>
to relate these two together, which we call <code class="language-tawny">hasComponent</code> and <code class="language-tawny">isComponentOf</code>. The
semantics of this statement is to say that we now have two properties that we
can use between individuals.
<!--l. 329--><p class="indent" >   As with classes, there is more that we can say about these properties. In this
case, the properties are natual opposites or inverses of each other. The semantics
of this statement is that for an individual <code class="language-tawny">i</code> which <code class="language-tawny">hasComponent</code> <code class="language-tawny">j</code>, we can say
that <code class="language-tawny">j</code> <code class="language-tawny">isComponentOf</code> <code class="language-tawny">i</code> also.
<!--l. 334--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-inverse
 (defoproperty hasComponent)
 (defoproperty isComponentOf))
</code></pre>
<!--l. 340--><p class="indent" >   The semantics here are actually between individuals, rather than classes. This
has an important consequence with the inverses. We might make the statement
that <code class="language-tawny">Pizza</code> <code class="language-tawny">hasComponent</code> <code class="language-tawny">PizzaComponent</code>, but this does not allow us to infer that
<code class="language-tawny">PizzaComponent</code> <code class="language-tawny">isComponentOf</code> <code class="language-tawny">Pizza</code>. The way that we have named our classes
for pizzas, this might be unintuitive. Consider bikes instead: just because all
bicycles have wheels, we can not assume that all wheels are parts of a bike;
we <span 
class="cmbx-10x-x-109">can </span>assume that where a bike has a wheel, that wheel is part of a
bike. This form of semantics is quite subtle, and is an example of where
statements made in OWL are saying less than most people would assume
<span class="footnote-mark"><a 
href="#fn7x6" id="fn7x6-bk"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-34002f7"></a>.
<!--l. 354--><p class="indent" >   We now move on to describe the relationships between <code class="language-tawny">Pizza</code> and both of
<code class="language-tawny">PizzaBase</code> and <code class="language-tawny">PizzaTopping</code>. For this, we will introduce three new parts of OWL:
subproperties, domain and range constraints and property characteristics, which
we define in Tawny-OWL as follows:
<!--l. 359--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasTopping
  :super hasComponent
  :range PizzaTopping
  :domain Pizza)

(defoproperty hasBase
  :super hasComponent
  :characteristic :functional
  :range PizzaBase
  :domain Pizza)
</code></pre>
<!--l. 372--><p class="indent" >   First, we consider sub-properties, which are fairly analogous to sub-classes.
For example, if two individuals <code class="language-tawny">i</code> and <code class="language-tawny">j</code> are related so that <code class="language-tawny">i&#x00A0;hasTopping&#x00A0;j</code>, then
it is also true that <code class="language-tawny">i&#x00A0;hasComponent&#x00A0;j</code>.
<!--l. 376--><p class="indent" >   Domain and range constraints describe the kind of entity that be at either
end of the property. So, for example, considering <code class="language-tawny">hasTopping</code>, we say that the
domain is <code class="language-tawny">Pizza</code>, so only instances of <code class="language-tawny">Pizza</code> can have a topping, while
the range is <code class="language-tawny">PizzaTopping</code> so only instances of <code class="language-tawny">PizzaTopping</code> can be a
topping.
<!--l. 381--><p class="indent" >   Finally, we introduce a <span 
class="cmti-10x-x-109">characteristic</span>. OWL has quite a few different
characteristics which will introduce over time; in this case <span 
class="cmti-10x-x-109">functional </span>means
means that there can be only one of these, so an individual has only a
single base. We do not make the same statement about toppings, so by
default, OWL will assume that you can have any number of toppings on a
pizza.
   <h3 class="sectionHead"><span class="titlemark">5.6   </span> <a 
 id="x1-350005.6"></a>Populating the Ontology</h3>
<!--l. 391--><p class="noindent" >We now have enough expressivity to describe quite a lot about pizzas. So, we can
now set about creating a larger set of toppings for our pizzas. First, we
describe some top level categories of types of topping. As before, we use
<code class="language-tawny">as-subclasses</code> function and state further that all of these classes are disjoint.
Here, we have not used the <code class="language-tawny">:cover</code> option. This is deliberate, because we
cannot be sure that these classes describe all of the different toppings
we might have; there might be toppings which fall into none of these
categories<span class="footnote-mark"><a 
href="#fn8x6" id="fn8x6-bk"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-35001f8"></a>.
<!--l. 403--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 PizzaTopping
 :disjoint
 (defclass CheeseTopping)
 (defclass FishTopping)
 (defclass FruitTopping)
 (defclass HerbSpiceTopping)
 (defclass MeatTopping)
 (defclass NutTopping)
 (defclass SauceTopping)
 (defclass VegetableTopping))
</code></pre>
<!--l. 417--><p class="indent" >   When defining a large number of classes at once, Tawny-OWL also offers a
shortcut, which is <code class="language-tawny">declare-classes</code>. While this can be useful in a few specific
circumstances, these are quite limited because it does not allow addition of any
other attributes at the same time, and in particular labels which most classes will
need. It is quite useful in tutorial document.
<!--l. 424--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 CheeseTopping
 :disjoint

 (declare-classes
  GoatsCheeseTopping
  GorgonzolaTopping
  MozzarellaTopping
  ParmesanTopping))
</code></pre>
<!--l. 436--><p class="indent" >   A similar, if slightly longer-winded, way of defining many classes at once is
<code class="language-tawny">defclassn</code>. We use this to define vegetables.
<!--l. 439--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 VegetableTopping
 :disjoint

 (defclassn
  [PepperTopping
    :label "Pepper Topping"]
  [GarlicTopping
    :label "Garlic Topping"]
  [PetitPoisTopping]
  [AsparagusTopping]
  [TomatoTopping]
  [ChilliPepperTopping]))
</code></pre>
<!--l. 455--><p class="indent" >   We add classes describing meat.
<!--l. 457--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 MeatTopping
 :disjoint
 (defclass HamTopping)
 (defclass PepperoniTopping))
</code></pre>
<!--l. 465--><p class="indent" >   And, finally, fruit.
<!--l. 467--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
 FruitTopping
 (defclass PineappleTopping))
</code></pre>
<!--l. 473--><p class="indent" >   In this case, we have only a single entity, that is <code class="language-tawny">PineappleTopping</code>, so we have
not made this disjoint. In fact, Tawny-OWL would treat this as an error, since
having a single disjoint class does not really make sense, and it is mostly likely it
is wrong. This does mean that we need to remember to add this <code class="language-tawny">:disjoint</code>
statement, if another <code class="language-tawny">FruitTopping</code> is added.
   <h3 class="sectionHead"><span class="titlemark">5.7   </span> <a 
 id="x1-360005.7"></a>Describing a Pizza</h3>
<!--l. 483--><p class="noindent" >And, now finally, we have the basic concepts that we need to build a pizza. First,
we start off with a generic description of a pizza; we have already defined the
class above, so we want to extend the definition rather than create a new one. We
can achieve this using the <code class="language-tawny">class</code> function:
<!--l. 488--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(owl-class Pizza
            :super
            (owl-some hasTopping PizzaTopping)
            (owl-some hasBase PizzaBase))
</code></pre>
<!--l. 495--><p class="indent" >   This introduces several new features of Tawny-OWL:
     <ul class="itemize1">
     <li class="itemize">this use of <code class="language-tawny">class</code> requires that <code class="language-tawny">Pizza</code> already be defined. In other words,
     we are extending an existing definition. If <code class="language-tawny">Pizza</code> is not defined, this
     form will crash.
     </li>
     <li class="itemize">a new function <code class="language-tawny">some</code>
     </li>
     <li class="itemize">we create out first <span 
class="cmti-10x-x-109">unnamed </span>classes from a class expression &#8211; in this
     case <code class="language-tawny">(owl-some&#x00A0;hasTopping&#x00A0;PizzaTopping)</code>.</li></ul>
<!--l. 505--><p class="indent" >   The semantics of the last two of these are a little complex. Like a named class
(all of those we have seen up to now), an unnamed class defines a set of
individuals, but it does so by combining other parts of the ontology. The
<code class="language-tawny">owl-some</code> restriction describes a class of individuals with at least one relationship
of a particular type. So <code class="language-tawny">(owl-some&#x00A0;hasTopping&#x00A0;PizzaTopping)</code> describes the set of
all individuals related by the <code class="language-tawny">hasTopping</code> relationship to at least one
<code class="language-tawny">PizzaTopping</code>. Or alternatively, each <code class="language-tawny">Pizza</code> must have a <code class="language-tawny">PizzaTopping</code>. Or,
alternatively again, for each <code class="language-tawny">Pizza</code> there must exist one <code class="language-tawny">PizzaTopping</code>; it is
for this reason that this form of class is also known as an <span 
class="cmti-10x-x-109">existential</span>
<span 
class="cmti-10x-x-109">restriction</span>.
<!--l. 517--><p class="indent" >   We combine the two statements to say that a <code class="language-tawny">Pizza</code> must have at least one
base and at least one topping. Actually, we earlier defined <code class="language-tawny">hasBase</code> with the
<code class="language-tawny">:functional</code> characteristic, so together this says that a <code class="language-tawny">Pizza</code> must have exactly
one base.
<!--l. 522--><p class="indent" >   Finally, we can build a specific pizza, and we start with one of the simplest
pizza, that is the margherita. This has two toppings, mozzarella and tomato. The
definition for this is as follows:
<!--l. 526--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass MargheritaPizza
  :super
  Pizza
  (owl-some hasTopping MozzarellaTopping)
  (owl-some hasTopping TomatoTopping)
  (only hasTopping (owl-or MozzarellaTopping TomatoTopping)))
</code></pre>
<!--l. 535--><p class="indent" >   The first part of this definition is similar to <code class="language-tawny">Pizza</code>. It says that a
<code class="language-tawny">MargheritaPizza</code> is a <code class="language-tawny">Pizza</code> with two toppings, mozzarella and tomato. The
second part of the definition adds two new features of Tawny-OWL:
     <ul class="itemize1">
     <li class="itemize"><code class="language-tawny">only</code> a new function which returns a <span 
class="cmti-10x-x-109">universal restriction</span>
     </li>
     <li class="itemize"><code class="language-tawny">owl-or</code> which returns a <span 
class="cmti-10x-x-109">union restriction</span></li></ul>
<!--l. 544--><p class="indent" >   The <code class="language-tawny">owl-or</code> statement defines the set of individuals that is either
<code class="language-tawny">MozzarellaTopping</code> or <code class="language-tawny">TomatoTopping</code>. The <code class="language-tawny">only</code> statement defines the set of
individuals whose toppings are either <code class="language-tawny">MozzarellaTopping</code> or <code class="language-tawny">TomatoTopping</code>. One
important sting in the tail of <code class="language-tawny">only</code> is that it does <span 
class="cmbx-10x-x-109">NOT </span>state that these individuals
have any toppings at all. So <code class="language-tawny">(only&#x00A0;hasTopping&#x00A0;MozzarellaTopping)</code> would cover a
<code class="language-tawny">Pizza</code> with only <code class="language-tawny">MozzarellaTopping</code>, but also many other things, including things
which are not <code class="language-tawny">Pizza</code> at all. Logically, this makes sense, but it is counter-intuitive
<span class="footnote-mark"><a 
href="#fn9x6" id="fn9x6-bk"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-36001f9"></a>.
<!--l. 555--><p class="indent" >   For completeness, we also define <code class="language-tawny">HawaiianPizza</code>
<span class="footnote-mark"><a 
href="#fn10x6" id="fn10x6-bk"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-36002f10"></a>.
<!--l. 560--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass HawaiianPizza
  :super
  Pizza
  (owl-some hasTopping MozzarellaTopping)
  (owl-some hasTopping TomatoTopping)
  (owl-some hasTopping HamTopping)
  (owl-some hasTopping PineappleTopping)
  (only hasTopping
         (owl-or MozzarellaTopping TomatoTopping HamTopping PineappleTopping)))
</code></pre>
<!--l. 572--><p class="indent" >   We can now check that this works as expected by using the <code class="language-tawny">subclass?</code> and
<code class="language-tawny">subclasses</code> functions at the REPL.
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-7">
take.wing.pizza&#x003E;&#x00A0;(subclass?&#x00A0;Pizza&#x00A0;MargheritaPizza)
&#x00A0;<br />true
&#x00A0;<br />take.wing.pizza&#x003E;&#x00A0;(subclasses&#x00A0;Pizza)
&#x00A0;<br />#{#[Class&#x00A0;0x74c8b756&#x00A0;"HawaiianPizza"@en]&#x00A0;#[Class&#x00A0;0x4f1495bd&#x00A0;"MargheritaPizza"@en]}
</div>
<!--l. 580--><p class="nopar" >
   <h3 class="sectionHead"><span class="titlemark">5.8   </span> <a 
 id="x1-370005.8"></a>A simple pattern</h3>
<!--l. 585--><p class="noindent" >The last definition is rather unsatisfying for two reasons. Firstly, the multiple
uses of <code class="language-tawny">(owl-some&#x00A0;hasTopping)</code> and secondly because the toppings are duplicated
between the universal and existential restrictions. Two features of Tawny-OWL
enable us to work around these problems.
<!--l. 590--><p class="indent" >   Firstly, the <code class="language-tawny">owl-some</code> function has a special property &#8211; it <span 
class="cmti-10x-x-109">broadcasts</span>. This
means it can take a single property but any number of classes; this is equivalent
to multiple calls to the <code class="language-tawny">owl-some</code> with a single class. We use this feature to
shorten the definition of <code class="language-tawny">AmericanPizza</code>.
<!--l. 596--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass AmericanPizza
  :super
  Pizza
  (owl-some hasTopping MozzarellaTopping
             TomatoTopping PepperoniTopping)
  (only hasTopping (owl-or MozzarellaTopping TomatoTopping PepperoniTopping)))
</code></pre>
<!--l. 605--><p class="indent" >   The single <code class="language-tawny">owl-some</code> function call here expands to three existential
restrictions, each of which becomes a super class of <code class="language-tawny">AmericanPizza</code> &#8211; mirroring
the definition of <code class="language-tawny">HawaiianPizza</code>.
<!--l. 609--><p class="indent" >   This definition, however, still leaves the duplication between the two sets of
restrictions. This pattern is frequent enough that Tawny-OWL provides special
support for it in the form of the <code class="language-tawny">some-only</code> function, which we use to define the
next pizza.
<!--l. 614--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass AmericanHotPizza
  :super
  Pizza
  (some-only hasTopping MozzarellaTopping TomatoTopping
              PepperoniTopping ChilliPepperTopping))
</code></pre>
<!--l. 622--><p class="indent" >   The <code class="language-tawny">some-only</code> function is Tawny-OWL&#8217;s implementation of the <span 
class="cmti-10x-x-109">closure</span>
axiom. Similarly, the use of <code class="language-tawny">:cover</code> described earlier implements the <span 
class="cmti-10x-x-109">covering</span>
axiom. These are the only two patterns which are directly supported by the core
of Tawny-OWL (i.e. the namespace <code class="language-tawny">tawny.owl</code>). In later sections, though, we will
see how to exploit the programmatic nature of Tawny-OWL to build arbitrary
new patterns for yourself.
   <h3 class="sectionHead"><span class="titlemark">5.9   </span> <a 
 id="x1-380005.9"></a>Defined Classes</h3>
<!--l. 632--><p class="noindent" >So far all of the classes that we have written are <span 
class="cmti-10x-x-109">primitive</span>. This is not a
statement about their complexity. It means that as they stand, they cannot
be used to infer new facts. So, for example, we know that a individual
<code class="language-tawny">MargheritaPizza</code> will have a <code class="language-tawny">MozzarellaTopping</code> and a <code class="language-tawny">TomatoTopping</code>, but given
an arbitrary pizza we cannot determine whether it is a margherita. Or,
mozzarella and tomato toppings are <span 
class="cmti-10x-x-109">necessary </span>for a margherita, but they are not
sufficient.
<!--l. 641--><p class="indent" >   Defined classes allow us to take advantage of the power of computational
reasoning. Let us try a simple example:
<!--l. 644--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass VegetarianPizza
  :equivalent
  (owl-and Pizza
            (only hasTopping
                   (owl-not (owl-or MeatTopping FishTopping)))))
</code></pre>
<!--l. 652--><p class="indent" >   Here, we define a <code class="language-tawny">VegetarianPizza</code> as a <code class="language-tawny">Pizza</code> with only <code class="language-tawny">MeatTopping</code> or
<code class="language-tawny">FishTopping</code>. The two key point about this definition is that we have marked it as
<code class="language-tawny">:equivalent</code> rather than <code class="language-tawny">:super</code> and that there is no stated relationship
between <code class="language-tawny">VegetarianPizza</code> and <code class="language-tawny">MargheritaPizza</code>. We can confirm this at the
shell.
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-8">
(subclasses&#x00A0;VegetarianPizza)
&#x00A0;<br />=&#x003E;&#x00A0;#{}
&#x00A0;<br />(subclass?&#x00A0;VegetarianPizza&#x00A0;MargheritaPizza)
&#x00A0;<br />=&#x003E;&#x00A0;false
</div>
<!--l. 664--><p class="nopar" >
<!--l. 666--><p class="indent" >   However, now let us ask the same question of a reasoner. You may remember
that earlier we added <code class="language-tawny">tawny.reasoner</code> to our namespace form. This now allows us
to perform computational reasoning. First, we choose a reasoner to use (in this
case HermiT); we do this by calling the <code class="language-tawny">reasoner-factory</code> function; this is in the
<code class="language-tawny">tawny.reasoner</code> namespace, which we can call by the short-cut name
<code class="language-tawny">r</code>.
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-9">
(r/reasoner-factory&#x00A0;:hermit)
&#x00A0;<br />=&#x003E;&#x00A0;#object[org.semanticweb.HermiT.Reasoner$ReasonerFactory&#x00A0;0x7d56d721&#x00A0;"org.semanticweb.HermiT.Reasoner$ReasonerFactory@7d56d721"]
</div>
<!--l. 676--><p class="nopar" >
<!--l. 678--><p class="indent" >   Then ask the same questions of Tawny-OWL but now using the versions of
functions prefixed with an <code class="language-tawny">i</code> (for inferred).
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-10">
(r/isubclasses&#x00A0;VegetarianPizza)
&#x00A0;<br />=&#x003E;&#x00A0;#{#[Class&#x00A0;0x6487d60d&#x00A0;"MargheritaPizza"@en]}
&#x00A0;<br />(r/isubclass?&#x00A0;VegetarianPizza&#x00A0;MargheritaPizza)
&#x00A0;<br />=&#x003E;&#x00A0;true
</div>
<!--l. 686--><p class="nopar" >
<!--l. 688--><p class="indent" >   Now, we see a different result. A <code class="language-tawny">MargheritaPizza</code> is a subclass of
<code class="language-tawny">VegetarianPizza</code>, even those we have never stated this explicitly. The reasoner
can infer this using the following chain of logic:
     <ul class="itemize1">
     <li class="itemize"><code class="language-tawny">MargheritaPizza</code> has only <code class="language-tawny">MozzarellaTopping</code> or <code class="language-tawny">TomatoTopping</code>
     </li>
     <li class="itemize"><code class="language-tawny">MozzarellaTopping</code> is a <code class="language-tawny">CheeseTopping</code>
     </li>
     <li class="itemize"><code class="language-tawny">TomatoTopping</code> is a <code class="language-tawny">VegetableTopping</code>
     </li>
     <li class="itemize"><code class="language-tawny">CheeseTopping</code> is disjoint from <code class="language-tawny">MeatTopping</code> and <code class="language-tawny">FishTopping</code>
     </li>
     <li class="itemize">Likewise, <code class="language-tawny">TomatoTopping</code> is not a <code class="language-tawny">MeatTopping</code> or <code class="language-tawny">FishTopping</code>
     </li>
     <li class="itemize">Therefore,   <code class="language-tawny">MargheritaPizza</code>  has   only   toppings   which   are   not
     <code class="language-tawny">MeatTopping</code> or <code class="language-tawny">FishTopping</code>.
     </li>
     <li class="itemize">A <code class="language-tawny">VegetarianPizza</code> is any <code class="language-tawny">Pizza</code> which has only toppings which are not
     <code class="language-tawny">MeatTopping</code> or <code class="language-tawny">FishTopping</code>.
     </li>
     <li class="itemize">So, a <code class="language-tawny">MargheritaPizza</code> is a <code class="language-tawny">VegetarianPizza</code>.</li></ul>
<!--l. 705--><p class="indent" >   Even for this example, the chain of logic that we need to draw our inference is
quite long. The version of the pizza ontology presented here is quite small, so
while we can follow and reproduce this inference easily by hand. For a larger
ontology it would be a lot harder, especially, when we start to make greater use
of the expressivity of OWL.
<!--l. 712--><p class="indent" >   Many of the statements that we have made about pizza are needed to make
this inference. For example, if we had not added <code class="language-tawny">:disjoint:</code> to the subclasses of
<code class="language-tawny">PizzaTopping</code>, we could not make this inference; even though we would know
that, for example, a <code class="language-tawny">MozzarellaTopping</code> was a <code class="language-tawny">CheeseTopping</code>; by default, the
reasoner would not assume that <code class="language-tawny">CheeseTopping</code> was not a <code class="language-tawny">MeatTopping</code>,
since these two could overlap. There are also some statements in the
ontology that we do not use to make this inference. For example, the
reasoner does not need to know that a <code class="language-tawny">MargheritaPizza</code> actually has a
<code class="language-tawny">MozzarellaTopping</code> (the statement <code class="language-tawny">(some&#x00A0;hasTopping&#x00A0;MozzarellaTopping)</code>, just
that if the pizza has toppings at all, they are only mozzarella or tomato. The
semantics of OWL can be subtle, but allow us to draw extremely powerful
conclusions.
   <h3 class="sectionHead"><span class="titlemark">5.10   </span> <a 
 id="x1-390005.10"></a>Recap</h3>
<!--l. 727--><p class="noindent" >In this chapter, we have described:
     <ul class="itemize1">
     <li class="itemize">The basic syntax of Tawny-OWL
     </li>
     <li class="itemize">New ontologies are created with <code class="language-tawny">defontology</code>
     </li>
     <li class="itemize">Ontologies consist of classes and properties
     </li>
     <li class="itemize">Classes describe a set of individuals
     </li>
     <li class="itemize">Properties describe relationships between individuals
     </li>
     <li class="itemize">Defined  classes  allow  us  to  make  inferences  using  comptutational
     reasoning.</li></ul>
<!--l. 739--><p class="indent" >   In addition, we have introduced the following semantic statements:
     <ul class="itemize1">
     <li class="itemize">Subclass relationships
     </li>
     <li class="itemize">Disjoint classes
     </li>
     <li class="itemize">Covering axioms
     </li>
     <li class="itemize">Inverse properties
     </li>
     <li class="itemize">Domain and range constraints
     </li>
     <li class="itemize">Functional characteristics
     </li>
     <li class="itemize"><code class="language-tawny">some</code> and <code class="language-tawny">only</code> restrictions, and the <code class="language-tawny">some-only</code> pattern
     </li>
     <li class="itemize"><code class="language-tawny">or</code> and <code class="language-tawny">not</code> restrictions</li></ul>
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;6</span><br /><a 
 id="x1-400006"></a>Highly Patterned Ontologies</h2>
<!--l. 4--><p class="noindent" >Many ontologies contain patterns&#8212;that is collections of classes and properties
which occur repetitive through the ontology. Dealing with this in many ontology
development environments is painful. Tawny-OWL is a fully programmatic
environment, however. Patterns are dealt with by writing functions and passing
parameters; in otherwords, the same way that we deal with code duplication
more generally.
<!--l. 11--><p class="indent" >   In this Chapter, we will first explore how to use patterns than Tawny-OWL
provides explicit support for; then we will move on to show how to modify and
extend these patterns in an ontology specific way. Finally, we will show how to
use the fully programmatic capabilies of Tawny-OWL to generate a large number
of classes in a way that is unique to one ontology.
   <h3 class="sectionHead"><span class="titlemark">6.1   </span> <a 
 id="x1-410006.1"></a>Dealing with Patterns</h3>
<!--l. 21--><p class="noindent" >Some ontologies have very few patterns; all the classes and objects are unique.
These ontologies tend to be very small, however. Most ontologies describe many
similar things with just a few details differing between them. In this chapter, we
use the amino-acid ontology &#8211; this describes the chemical constituants that make
up proteins. There are twenty of these and they are all very similar, with the
same properties.
<!--l. 28--><p class="indent" >   Graphical tools can provide a partial solution to this problem, by supporting
the building of these patterns. For instance, Protege had &#8220;wizards&#8221; to build
various patterns. In fact, the first version of the amino-acid ontology was built to
demonstrate one of these patterns <span class="cite">[<span 
class="cmbx-10x-x-109">?</span>]</span>. This requires extension of the editor
for every new pattern, which is acceptable for some generic patterns
which can be widely reused, but works badly for patterns with a narrow
scope.
<!--l. 36--><p class="indent" >   An alternative is to use a language like OPPL&#x00A0;<span class="cite">[<span 
class="cmbx-10x-x-109">?</span>]</span>, which can directly specify
patterns and transformations to ontologies. However, this requires the use
of two syntaxes or environments &#8211; one for &#8220;normal&#8221; ontological code,
and one for patternised. It also presents a maintainence problem &#8211; the
normal and patternised code is intertwinned, so updating a pattern is
difficult.
<!--l. 43--><p class="indent" >   Tawny-OWL take an alternative approach. Instead of providing an alternative
language like OPPL, all ontological statements are written in Clojure, which is,
itself, an full programming languages. Patterns can be built straight-forwardly
by writing or using functions; this can be done in a general library for
generic patterns, shared between ontologies. Or, alternatively, it can be
done specifically for individual ontologies, in the same syntax, files and
development environment as the normal parts. Updates cease to be a problem;
in the worst case scenario, this requires restarting the clojure process.
Normally, it does not require even that. In short, with Tawny-OWL patterns
become an integral part of ontology development, rather than an external
imposition.
<!--l. 56--><p class="indent" >   In this chapter, we first describe how to use an pre-existing pattern provided
by Tawny-OWL, then how to modify this slightly for the amino-acid ontology.
Finally, we show how to create a <span 
class="cmti-10x-x-109">de novo </span>patternised section creating several
hundred defined classes.
<!--l. 61--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x1-420006.2"></a>Creating the Amino Acid Ontology</h3>
<!--l. 64--><p class="noindent" >First, we start with a namespace declaration. This is slightly different from ones
used before, as it also <code class="language-tawny">require</code>s two new namespaces. <code class="language-tawny">tawny.pattern</code> provides
pattern support and one key pattern which forms the core of the amino-acid
ontology; <code class="language-tawny">clojure.string</code> provides string maninpulation capabilities which we
will use. We also define the new ontology.
<!--l. 70--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(ns take.wing.amino-acid
  (:import [org.semanticweb.owlapi.search EntitySearcher])
  (:require
    [clojure.string]
    [tawny.owl :refer :all]
    [tawny.pattern :as p]
    [tawny.reasoner :as r]
    [tawny.util :as u]))

(defontology aao
  :iri "http://www.purl.org/ontolink/aao")
</code></pre>
<!--l. 84--><p class="indent" >   First, to explain the domain. Proteins are polymers made up from amino-acid
monomers. They consist of a central carbon atom, attached to a carboxyl group
(the &#8220;acid&#8221; amino) and amine group (the &#8220;amino&#8221; group) a hydrogen
and an R group. The R group defines the different amino acids. The
different R groups have different phyiscal or chemical properties, such as
their degree of hydrophobicity. We call these different characteristics
<code class="language-tawny">RefiningFeatures</code>.
<!--l. 91--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass AminoAcid)

(defclass RefiningFeature)
(defclass PhysicoChemicalProperty :super RefiningFeature)
</code></pre>
<!--l. 98--><p class="indent" >   There are a number of different ways of measuring hydrophobicity; in reality,
it is a continuous property rather than a discrete one, but these are hard to
model ontologically. One simple solution to this problem is the <span 
class="cmti-10x-x-109">value partition </span>&#8211;
we just pick a set of discrete values into which we partition the range. It is the
same trick that is used to describe the colours of the rainbow; we force a
continuous range into seven colours. Hydrophobicity splits into just two &#8211;
hydrophobic and hydrophilic.
<!--l. 106--><p class="indent" >   The full representation of this knowledge as a value parition is fairly complex.
First, we define a root class and an object property, with an appropriate domain
and range, and declared functional, as one object can be hydrophilic or
hydrophobic but not both.
<!--l. 111--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Hydrophobicity :super PhysicoChemicalProperty)

(defoproperty hasHydrophobicity :domain AminoAcid
  :range Hydrophobicity :characteristic :functional)
</code></pre>
<!--l. 118--><p class="indent" >   Next we need to define the partition values. We make <code class="language-tawny">Hydrophilic</code> disjoint
from <code class="language-tawny">Hydrophobic</code>. We do not make <code class="language-tawny">Hydrophobic</code> disjoint from <code class="language-tawny">Hydrophillic</code>
because of Tawny-OWLs &#8220;define before use&#8221; semantics.
<!--l. 123--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Hydrophobic :super Hydrophobicity)
(defclass Hydrophilic :super Hydrophobicity :disjoint Hydrophobic)
</code></pre>
<!--l. 128--><p class="indent" >   Finally, we <code class="language-tawny">refine</code> the first partition <code class="language-tawny">Hydrophobic</code> to also be disjoint with
<code class="language-tawny">Hydrophilic</code> and then add a covering axioms to <code class="language-tawny">Hydrophobicity</code>.
<!--l. 131--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(refine Hydrophobic
  :disjoint Hydrophilic)

(refine Hydrophobicity
  :equivalent (object-or Hydrophilic Hydrophobic))
</code></pre>
<!--l. 139--><p class="indent" >   Of course, as we have already seen, the use of disjoints and covering axioms is
so common that Tawny-OWL provides specific support for adding these, in a way
which also allows us to avoid the necessity for refining classes after creation. This
produces a much neater definition and is a simple example of the use of
patterns.
<!--l. 145--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-subclasses
    (defclass Hydrophobicity :super PhysicoChemicalProperty)
  :disjoint :cover
  (defclass Hydrophobic)
  (defclass Hydrophilic))

(defoproperty hasHydrophobicity :domain AminoAcid
   :range Hydrophobicity :characteristic :functional))
</code></pre>
<!--l. 156--><p class="indent" >   This is, however, all still fairly long-winded and relatively easy to get wrong.
Tawny-OWL, however, allows us to go further with the use of the <code class="language-tawny">defpartition</code>
macro, which allows specification of all the appropriate values at once. It will
produce the same axioms as the statements above.
<!--l. 162--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(p/defpartition Hydrophobicity
  [Hydrophobic Hydrophilic]
  :comment "The tendency to associate with water."
  :super PhysicoChemicalProperty
  :domain AminoAcid)
</code></pre>
<!--l. 170--><p class="indent" >   <code class="language-tawny">defpartition</code> is a generic pattern and is not specific at all to the amino-acid
ontology. It will serve well, but for the amino-acid ontology we need to define a
series of further value partitions. They all have the same super class and domain.
It would be nice to create a <span 
class="cmti-10x-x-109">localised </span>pattern which hard-codes these
values. As <code class="language-tawny">defpartition</code> is a macro this is slightly more complex than
a normal function, but not heavily so. This macro is unlikely to be of
use in another ontology because of these hard-coded values, but it is
valuable because it saves typing here and safe-guards us against future
changes. Being in the same environment, it is easy to do, so we might as
well!
<!--l. 182--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defmacro defaapartition [& body]
  `(p/defpartition
     ~@body :super PhysicoChemicalProperty
     :domain AminoAcid))
</code></pre>
<!--l. 189--><p class="indent" >   The next value partition is as a result somewhat smaller, as it no longer
needs to describe the super class and domain. The size value partition is
self-explanatory enough; this could be described in relation to a continuous
physical measurement (such as size in Daltons), but this is not necessary
here.
<!--l. 195--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defaapartition Size
  [Small Tiny Large]
  :comment "The physical size of the amino acid.")
</code></pre>
<!--l. 201--><p class="indent" >   Finally, we create three more value partitions describing <code class="language-tawny">Charge</code>,
<code class="language-tawny">SideChainStructure</code> and <code class="language-tawny">Polarity</code>.
<!--l. 204--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defaapartition Charge
  [Negative Neutral Positive]
  :comment "The charge of an amino acid.")

(defaapartition SideChainStructure
  [Aliphatic Aromatic]
  :comment "Does the side chain contain rings or not?")

(defaapartition Polarity
  [Polar NonPolar]
  :comment "The polarity across the amino acid.")
</code></pre>
<!--l. 218--><p class="indent" >   Next, we define a set of annotation properties. In the previous Chapter&#x00A0;<a 
href="#x1-290005">5<!--tex4ht:ref: cha:pizza-ontology --></a>, we
made some use of a few annotation properties: the label and the comment. But,
in OWL, annotation properties are generic. It is possible to define new
annotation properties. This is useful here because amino-acids have a long name,
such as <code class="language-tawny">Alanine</code>, and two shorter names &#8211; a three letter abbreviation such as <code class="language-tawny">Ala</code>
and finally one letter abbreviation which is shorter, but harder to remember, in
this case <code class="language-tawny">A</code>. These abbreviations are standardized and widely used, so worth
describing here.
<!--l. 228--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">;; annotation properties
(defaproperty hasLongName)
(defaproperty hasShortName)
(defaproperty hasSingleLetterName)
</code></pre>
<!--l. 235--><p class="indent" >   Now, we move onto the heart of this amino-acid ontology which is the
function which defines a single amino-acid. This is a fairly large definition, but it
is fairly repetitive in itself. First we start with the function definition, combined
with a few small pre-conditions; these are probably unnecessary in this case, for
reasons we will see soon.
<!--l. 241--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defn amino-acid
  "Define a new amino acid. Names is a vector with the long, three letter and
  single amino acid version. Properties are the five value partitions for each
  aa, as a list."
  [names properties]
  {:pre [(= 3 (count names))
          (= 5 (count properties))]}
</code></pre>
<!--l. 251--><p class="indent" >   The main part of the amino acid pattern is defined in the next section. The
pattern is not that complex &#8211; we simply give an amino-acid five properties and
three names. However, to achieve this, we use a new feature of Tawny-OWL: the
<code class="language-tawny">gem</code> and the <code class="language-tawny">facet</code>.
<!--l. 256--><p class="indent" >   The <code class="language-tawny">defpartition</code> macro that we saw earlier creates a large number of
different classes and a property associated with them. In addition to these logical
statements it also defines a <span 
class="cmti-10x-x-109">facet </span>which comprises the <span 
class="cmti-10x-x-109">facet values </span>(i.e. the
classes) and the <span 
class="cmti-10x-x-109">facet property</span>; this knowledge is stored in the ontology as
annotations and states that the facet values should normally be associated with
this property.
<!--l. 264--><p class="indent" >   This allows us to use the <code class="language-tawny">facet</code> function which returns much the same as
<code class="language-tawny">owl-some</code>.
<!--l. 267--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(=
  (owl-some hasSideChainStructure Aliphatic)
  (facet Aliphatic))
</code></pre>
<!--l. 273--><p class="indent" >   This is a minor convienience, of course, when lots of facet values are being
used at once is a big advantage. As with <code class="language-tawny">owl-some</code>, the <code class="language-tawny">facet</code> function broadcasts
&#8211; we can call it with as many arguments as we choose.
<!--l. 278--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(=
  (list
    (owl-some hasCharge Neutral)
    (owl-some hasHydrophobicity Hydrophobic)
    (owl-some hasPolarity NonPolar)
    (owl-some hasSideChainStructure Aliphatic)
    (owl-some hasSize Small))
  (facet Neutral Hydrophobic NonPolar Aliphatic Small))
</code></pre>
<!--l. 289--><p class="indent" >   Not only has the hassle of typing been reduced but so has the risk of
error. It is no longer possible to use the wrong property with the wrong
class.
<!--l. 293--><p class="indent" >   The <code class="language-tawny">gem</code> functions build on top of this idea; these are similar the <code class="language-tawny">class</code> or
<code class="language-tawny">defclass</code> functions described earlier, but add a new frame, that of the facet. For
example, we could define the amino-acid <code class="language-tawny">Valine</code> as follows:
<!--l. 298--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defgem Valine
  :facet Neutral Hydrophobic NonPolar Aliphatic Small)
</code></pre>
<!--l. 303--><p class="indent" >   In the case of the <code class="language-tawny">amino-acid</code> function, instead we use the <code class="language-tawny">gem</code> function and
capture its return value as part of a <code class="language-tawny">let</code> block. This is not strictly necessary as
the return value is used only once, but in this case, I think, it increases
readability.
<!--l. 308--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">  (let [aa (p/gem (first names)
                  :super AminoAcid
                  :facet properties
                  :label (first names)
                  :annotation
                  (annotation hasLongName (nth names 0))
                  (annotation hasShortName (nth names 1))
                  (annotation hasSingleLetterName (nth names 2)))]
</code></pre>
<!--l. 319--><p class="indent" >   The last part is not part of the pattern itself. Rather it adds support for
<span 
class="cmti-10x-x-109">interning</span>; this is the process by which OWL objects are bound to Clojure
symbols. The practical upshot of this is that we (or anyone importing the amino
acid ontology) will be able to refer to amino acids using names like <code class="language-tawny">Alanine</code>
rather than being required to use strings inside quotes &#8212; <code class="language-tawny">"Alanine"</code>.
This adds (considerable) complexity to the Tawny-OWL definition of the
amino-acid ontology, but is probably worth it for ease of downstream
use.
<!--l. 328--><p class="indent" >   To achieve this, we need to return instances of the <code class="language-tawny">tawny.pattern.Named</code> class,
combined with the strings we use to refer to them. In this case, a single
amino-acid class gets three names &#8211; this is rather unusual but makes sense
here.
<!--l. 333--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">    ;; and return types for intern
    (map p/-&gt;Named
          names
          (repeat aa))))
</code></pre>
<!--l. 340--><p class="indent" >   We could stop here in terms of generating our ontology. However, here we
take two more steps, one mostly to make the input more consistent, so that we
would see errors easily, and one to make the amino-acid ontology more usuable
within the Tawny-OWL environment.
<!--l. 345--><p class="indent" >   Firstly, we define a function which takes a number of different amino-acid
definitions and runs the amino-acid function over them. It then flattens the list of
lists that is returned.
<!--l. 349--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defn amino-acids
  [& definitions]
  (apply
   concat
   (map
    (fn [[names props]] (amino-acid names props))
    (partition 2 definitions))))
</code></pre>
<!--l. 359--><p class="indent" >   Finally, we define a macro. This does two things for us. Firstly it provides the
convienience of using &#8220;bear&#8221; words: so <code class="language-tawny">Alanine</code> instead of <code class="language-tawny">"Alanine"</code> within the
macro itself. A small convienience for a single amino-acid, but a bigger one for all
twenty. There are a variety of ways of achieving this &#8211; we could use the
<code class="language-tawny">tawny.util/quote-tree</code> macro to covert all the symbols to strings. However, here,
we take the slightly more complex route and just turn the first part of the
definition into strings. The rest can remain symbols as they are pre-defined. And,
secondly, we <span 
class="cmti-10x-x-109">intern </span>the <code class="language-tawny">Named</code> values turned from the <code class="language-tawny">amino-acid</code> function;
that is we create a new variable, identified by relevant symbol, with a
value which is an OWL entity. The practical upshort of this is that later,
we can refer to <code class="language-tawny">Alanine</code> (or <code class="language-tawny">Ala</code> or <code class="language-tawny">A</code>) rather than having to use quotes.
In terms of the amino-acid ontology itself, this is unnecessary, but it is
useful for another ontology importing the amino-acid ontology, so it is
worth doing here. In addition and probably more importantly than the
convienience, this also provides a degree of safety: attempts, for instance, refering
to an amino-acid <code class="language-tawny">B</code> will fail with an error as this amino-acid does not
exist.
<!--l. 380--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defmacro defaminoacids
  [& definitions]
  (let [definitions
         (interleave
          (map
           #(mapv name %)
           (take-nth 2 definitions))
          (take-nth 2 (rest definitions)))]
    `(p/intern-owl-entities
       (amino-acids ~@definitions))))
</code></pre>
<!--l. 393--><p class="indent" >   Then, we define all the amino-acid. These have been laid out in alphabetical
order, and the properties arranged in a table which means that we can visually
check that everything is correct and nothing is missing.
<!--l. 397--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defaminoacids
  [Alanine       Ala A] [Neutral  Hydrophobic NonPolar Aliphatic Tiny]
  [Arginine      Arg R] [Positive Hydrophilic Polar    Aliphatic Large]
  [Asparagine    Asn N] [Neutral  Hydrophilic Polar    Aliphatic Small]
  [Aspartate     Asp D] [Negative Hydrophilic Polar    Aliphatic Small]
  [Cysteine      Cys C] [Neutral  Hydrophobic Polar    Aliphatic Small]
  [Glutamate     Glu E] [Negative Hydrophilic Polar    Aliphatic Small]
  [Glutamine     Gln Q] [Neutral  Hydrophilic Polar    Aliphatic Large]
  [Glycine       Gly G] [Neutral  Hydrophobic NonPolar Aliphatic Tiny]
  [Histidine     His H] [Positive Hydrophilic Polar    Aromatic  Large]
  [Isoleucine    Ile I] [Neutral  Hydrophobic NonPolar Aliphatic Large]
  [Leucine       Leu L] [Neutral  Hydrophobic NonPolar Aliphatic Large]
  [Lysine        Lys K] [Positive Hydrophilic Polar    Aliphatic Large]
  [Methionine    Met M] [Neutral  Hydrophobic NonPolar Aliphatic Large]
  [Phenylalanine Phe F] [Neutral  Hydrophobic NonPolar Aromatic  Large]
  [Proline       Pro P] [Neutral  Hydrophobic NonPolar Aliphatic Small]
  [Serine        Ser S] [Neutral  Hydrophilic Polar    Aliphatic Tiny]
  [Threonine     Thr T] [Neutral  Hydrophilic Polar    Aliphatic Tiny]
  [Tryptophan    Trp W] [Neutral  Hydrophobic NonPolar Aromatic  Large]
  [Tyrosine      Try Y] [Neutral  Hydrophobic Polar    Aromatic  Large]
  [Valine        Val V] [Neutral  Hydrophobic NonPolar Aliphatic Small]
  )
</code></pre>
<!--l. 422--><p class="indent" >   Finally, we clean up by ensuring that all aminoc-acids are disjoint from each
other. We could do this earlier in the <code class="language-tawny">amino-acids</code> function, but as this function
only needs to be run once, it makes little difference.
<!--l. 426--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(apply as-disjoint (subclasses AminoAcid))
</code></pre>
   <h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x1-430006.3"></a>Defining the Amino Acids</h3>
<!--l. 433--><p class="noindent" >We saw earlier, while consider pizza, that it is possible to create defined classes
(see Section&#x00A0;<a 
href="#x1-380005.9">5.9<!--tex4ht:ref: defined --></a>). For the amino-acid ontology, this is also tremendously useful
because we can effectively use this to query it. Consider, for example, this
definition of <code class="language-tawny">LargeAminoAcid</code>.
<!--l. 439--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass LargeAminoAcid
  :equivalent (owl-some hasSize Large))
</code></pre>
<!--l. 444--><p class="indent" >   This is fine, of course, but is also very slow, as there are a lot of potential
classes that we could create. As well as one for each of the twelve values in our
five value partitions, we also need all of the permutations of these, which makes
quite a few classes.
<!--l. 449--><p class="indent" >   Of course, being fully programmatic, calculating permutations in
Tawny-OWL is a simple enough task; so, why not build all of these defined
classes programmatically?
<!--l. 453--><p class="indent" >   This is reasonably straight-forward; first, we need a definition for a defined
class; this will take a list of partition values. The pattern simply involves making
existential (<code class="language-tawny">owl-some</code>) restrictions to all of the partition values using the
appropriate object property; we can achieve this using the <code class="language-tawny">facet</code> function that we
saw earlier. We form the name of the class from the names of the partition
values.
<!--l. 460--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defn amino-acid-def [partition-values]
  (let [name
         (str
          (clojure.string/join
           (map
            #(.getFragment
              (.getIRI %))
            partition-values))
          "AminoAcid")
         exist (p/facet partition-values)]
</code></pre>
<!--l. 473--><p class="indent" >   Then finally we create the class and package it with its name. As with our
previous amino-acid definition, this function has a return value which would
allow it to be used to intern the classes created, although we do not actually use
that facility here.
<!--l. 478--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">    (p/-&gt;Named
     name
     (owl-class
       name
       :label name
       :equivalent
       (owl-and AminoAcid exist)))))
</code></pre>
<!--l. 488--><p class="indent" >   Calculating a cartesian product is relatively easy in Clojure using the
swiss-army knife <code class="language-tawny">for</code> list comprehension.
<!--l. 491--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defn cart [colls]
  (if (empty? colls)
    '(())
    (for [x (first colls)
           more (cart (rest colls))]
       (cons x more))))
</code></pre>
<!--l. 500--><p class="indent" >   We combine all of these together to create all of the defined classes.
<!--l. 502--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">;; build the classes
(doall
 (map
  amino-acid-def
  ;; kill the empty list
  (rest
   (map
    #(filter identity %)
    ;; combination of all of them
    (cart
     ;; list of values for each partitions plus nil
     (map
       #(cons nil (seq (direct-subclasses %)))
       ;; all our partitions
       (seq (direct-subclasses PhysicoChemicalProperty))))))))
</code></pre>
<!--l. 520--><p class="indent" >   Finally, we check to see whether everything has worked. For this, we will need
to use a reasoner, so first we choose a reasoner and check the consistency of our
ontology.
<!--l. 524--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(r/reasoner-factory :hermit)
(r/consistent?)
</code></pre>
<!--l. 529--><p class="indent" >   We can also investigate the classes that we have created. None of the created
classes should have any asserted subclasses, which we can check, by looking at
one.
<!--l. 532--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(subclasses
 (owl-class "SmallAminoAcid"))
</code></pre>
<!--l. 537--><p class="indent" >   However, we see a totally different picture with the reasoner. We can first
check for inferred subclasses.
<!--l. 540--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(r/isubclasses
 (owl-class "SmallAminoAcid"))
</code></pre>
<!--l. 545--><p class="indent" >   We might have expected to just see a few as there are only 20 amino-acids,
but actually, there are 113 of them. The reason for this is that the reasoner
determines the subclass relationships between the defined classes as well as with
the named amino-acids: so, for instance, an <code class="language-tawny">HydrophobicSmallAminoAcid</code> is
necessarily also a <code class="language-tawny">SmallAminoAcid</code> so appears as a subclass. This demonstrates the
power of using a computational reasoner; while the conclusions that it reaches are
not, in this case, difficult to calculate by hand, with so many classes they would
be laborious.
<!--l. 554--><p class="indent" >   Unfortunately, in this case, they also hide the answer that we are really
interested in. In a less programmatic tool, we would be stuck, but this is not a
problem in Tawny-OWL; we just filter the defined classes from the result as
follows.
<!--l. 559--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(filter
 #(not (EntitySearcher/isDefined % aao))
 (r/isubclasses
  (owl-class "SmallAminoAcid")))
;; =&gt; (#[Class 0x6f148b89 "Valine"@en] #[Class 0x4c949f3e "Proline"@en]
;;     #[Class 0x57f95b76 "Glutamate"@en] #[Class 0x784dcd0 "Asparagine"@en]
;;     #[Class 0x4c07576a "Aspartate"@en] #[Class 0x24024cbb "Cysteine"@en])
</code></pre>
<!--l. 569--><p class="indent" >   And the end result? There are six small amino-acids!
<!--l. 571--><p class="indent" >   With Tawny-OWL it is straight-forward to implement new patterns building
a very large number of classes at once; the amino acid ontology is a nice example
of this. At the current time, we do not really know how common the requirement
is for this sort of ontology; most ontologies in existance are not heavily
patternized. But, then, perhaps this is part because the tools for generating
patterns were not integrated into our ontology development process;
patternized ontologies are not common because they are just too painful to
produce.
<!--l. 580--><p class="indent" >   Even aside from heavily patternized ontologies, this chapter also shows that
Tawny-OWL can be easily extended even within the scope of a single ontology.
The <code class="language-tawny">defaapartition</code> macro is only useful here. But, it is easy to write, reduces
duplication and increases consistency of the end ontology. Most ontologies have
this form of repetition. With Tawny-OWL, managing this repetition becomes the
task of the computer and not the task of the human, which is as it should
be.
   <h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
 id="x1-440006.4"></a>Recap</h3>
<!--l. 591--><p class="noindent" >In this chapter, we have described:
     <ul class="itemize1">
     <li class="itemize">The <code class="language-tawny">tawny.pattern</code> namespace.
     </li>
     <li class="itemize">The Value-Partition design pattern
     </li>
     <li class="itemize">Gems and Facets
     </li>
     <li class="itemize">A macro expanding the value-partition.
     </li>
     <li class="itemize">An amino-acid function
     </li>
     <li class="itemize">Intern with <code class="language-tawny">intern-owl-entities</code>
     </li>
     <li class="itemize">A highly patternized part of the ontology.</li></ul>
                                                                     

                                                                     
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;7</span><br /><a 
 id="x1-450007"></a>More on Pizza</h2>
<!--l. 5--><p class="noindent" >Now that we have considered patterns in the context of amino-acids,
we can look again at Pizza. Our original version of the pizza ontology
used few patterns. Let&#8217;s try again. First we create the namespace and
ontology.
<!--l. 10--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(ns take.wing.advanced-pizza
  (:require [tawny.owl :refer :all]
             [tawny.pattern :as p]
             [tawny.util :as u]))

(defontology pizza
  :iri "http://purl.org/ontolink/advanced-pizza")
</code></pre>
<!--l. 20--><p class="indent" >   Next we create the classes that we need to describe the pizza structure.
<!--l. 23--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint
 (defclass Pizza)
 (defclass PizzaComponent))

(as-subclasses
 PizzaComponent
 :disjoint :cover
 (defclass PizzaTopping)
 (defclass PizzaBase))
</code></pre>
<!--l. 35--><p class="indent" >   And the relationships to link them together.
<!--l. 37--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasComponent)
(defoproperty hasBase
  :super hasComponent
  :domain Pizza
  :range PizzaTopping)

(defoproperty hasTopping
  :super hasComponent
  :domain Pizza
  :range PizzaTopping)
</code></pre>
<!--l. 50--><p class="indent" >   And, finally, we extend the definition of <code class="language-tawny">Pizza</code> to include the base and
topping.
<!--l. 53--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(owl-class Pizza
  :super (owl-some hasTopping PizzaTopping)
          (owl-some hasBase PizzaBase))
</code></pre>
<!--l. 59--><p class="indent" >   Previously, we started to define our toppings at this point, but let&#8217;s revisit
this. In terms of their structure, pizza toppings look rather like the properties we
saw with amino-acids. However, they are not really a value-partition, since
toppings are not a continuous range. Tawny-OWL provides a pattern for this
purpose which is called the <span 
class="cmti-10x-x-109">tier</span>. The tier is actually a generalization of the value
partition pattern with more options.
<!--l. 67--><p class="indent" >   We could use the tier like so:
<!--l. 69--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(deftier VegetableTopping
  [Artichoke Asparagus Olive]
  :function false :cover false :domain Pizza :suffix :Topping
  :superproperty hasTopping)
</code></pre>
<!--l. 76--><p class="indent" >   This would create three classes <code class="language-tawny">ArtichokeTopping</code>, <code class="language-tawny">AsparagusTopping</code> and
<code class="language-tawny">OliveTopping</code>, as well as a property <code class="language-tawny">hasVegetableTopping</code>. Unlike the value
partition, we do not want this property to be functional, since having more than
one vegetable topping on a pizza is a reasonable thing to do. Similarly, we do not
want to add a covering axiom; there are clearly more vegetable toppings in the
world than the three that we have named.
<!--l. 84--><p class="indent" >   Now, typing all of this for every type of topping would be painful. So, let&#8217;s
create a macro to do it for us. Macros of this form are relatively easy to create.
We start off with the macro name and parameters.
<!--l. 89--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defmacro deftoppings
   [name values])
</code></pre>
<!--l. 94--><p class="indent" >   Next we add the pattern that we want this to expand to.
<!--l. 96--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defmacro deftoppings
   [name values]
  (p/deftier VegetableTopping
    [Artichoke Asparagus Olive]
    :function false :cover false :domain Pizza :suffix :Topping
    :superproperty hasTopping))
</code></pre>
<!--l. 105--><p class="indent" >   Now we put a backtick <code class="language-tawny">&#8216;</code> in front of this form and replace the bits that we
want to parameterize with variables prefixed with <code class="language-tawny">~</code>.
<!--l. 108--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defmacro deftoppings
  [name values]
  `(p/deftier ~name ~values
     :suffix :Topping
     :functional false
     :domain Pizza
     :cover false
     :superproperty hasTopping))
</code></pre>
<!--l. 119--><p class="indent" >   Now we can use this to define all of our topping types.
<!--l. 121--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(deftoppings PizzaTopping
  [Cheese Fish Fruit HerbSpice Meat Nut Sauce Vegetable])
</code></pre>
<!--l. 126--><p class="indent" >   We can check that this actually does what we expect in a number of ways;
but let&#8217;s use the <code class="language-tawny">macroexpand-1</code> function to see what this will expand
to.
<!--l. 130--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">take.wing.advanced-pizza&gt; (macroexpand-1 '(deftoppings PizzaTopping [Cheese Fish Fruit HerbSpice Meat Nut Sauce Vegetable]));; take.wing.advanced-pizza&gt; (macroexpand-1 '(deftoppings PizzaTopping [Cheese Fish Fruit HerbSpice Meat Nut Sauce Vegetable]))
(tawny.pattern/deftier PizzaTopping [Cheese Fish Fruit HerbSpice Meat Nut Sauce Vegetable] :suffix :Topping :functional false :domain take.wing.advanced-pizza/Pizza :superproperty take.wing.advanced-pizza/hasTopping)
</code></pre>
<!--l. 135--><p class="indent" >   Slightly harder to read, but you should be able to convince
yourself that this is the same as the <code class="language-tawny">deftier</code> form that we started
with<span class="footnote-mark"><a 
href="#fn1x8" id="fn1x8-bk"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-45001f1"></a>.
We can now define all our toppings efficiently.
<!--l. 141--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(deftoppings CheeseTopping
  [GoatsCheese Gorgonzola Mozzarella Parmesan])

(deftoppings VegetableTopping
  [Pepper Garlic PetitPois Asparagus Tomato ChilliPepper Onion
   Peperonata TobascoPepperSauce Caper Olive Rocket])

(deftoppings MeatTopping
  [Ham Pepperoni])

(deftoppings FruitTopping
  [Pineapple Pear])

(deftoppings FishTopping
  [Anchovies Prawn])
</code></pre>
<!--l. 159--><p class="indent" >   We move on now to create our &#8220;named pizza&#8221; with specific ingredients. First
we create the top-level class.
<!--l. 162--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass NamedPizza
  :super Pizza)
</code></pre>
<!--l. 167--><p class="indent" >   We could create a similar macro to <code class="language-tawny">deftoppings</code> which we would use multiple
times for each pizza. This might look something like this perhaps:
<!--l. 171--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defpizza MargheritaPizza [MozzarellaTopping TomatoTopping])
</code></pre>
<!--l. 175--><p class="indent" >   However, we will go a different route, rather like <code class="language-tawny">defaminoacid</code> from
Chapter&#x00A0;<a 
href="#x1-400006">6<!--tex4ht:ref: cha:highly-patt-ontol --></a>. We will create a single macro which allows us to create many pizza at
once.
<!--l. 179--><p class="indent" >   To achieve this, we need to create a variable number of <code class="language-tawny">defclass</code> forms. The
macro to achiev this looks like this:
<!--l. 182--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defmacro defpizza [& body]
  `(do
    ~@(map
        (fn [[h & r]]
          `(defclass ~h :super
             (owl-some hasTopping ~@r)))
        body)))
</code></pre>
<!--l. 192--><p class="indent" >   This uses a number of features of Clojure: <code class="language-tawny">&amp;&#x00A0;body</code> makes this a variadic
function taking any number of parameters; the <code class="language-tawny">map</code> function operates
over the list of parameters and calls the <code class="language-tawny">fn</code> on them which takes a list
also, breaking it into <code class="language-tawny">h&#x00A0;&amp;&#x00A0;r</code> or head and rest. We call this macro like
so.
<!--l. 198--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defpizza
 [MargheritaPizza MozzarellaTopping TomatoTopping]

 [CajunPizza MozzarellaTopping OnionTopping PeperonataTopping
  PrawnTopping TobascoPepperSauceTopping TomatoTopping]

 [CapricciosaPizza AnchoviesTopping MozzarellaTopping
  TomatoTopping PeperonataTopping HamTopping CaperTopping
  OliveTopping]

 [ParmensePizza AsparagusTopping
  HamTopping
  MozzarellaTopping
  ParmesanTopping
  TomatoTopping]

 [SohoPizza OliveTopping RocketTopping TomatoTopping ParmesanTopping
  GarlicTopping])
</code></pre>
   <h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
 id="x1-460007.1"></a>Recap</h3>
<!--l. 223--><p class="noindent" >In this short chapter, we have described:
     <ul class="itemize1">
     <li class="itemize">The <code class="language-tawny">deftier</code> macro
     </li>
     <li class="itemize">Two macros in detail that we can use for the pizza ontology</li></ul>
                                                                     

                                                                     
                                                                     

                                                                     
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;8</span><br /><a 
 id="x1-470008"></a>Keeping it in the Family</h2>
   <h4 class="subsectionHead"><span class="titlemark">8.0.1   </span> <a 
 id="x1-480008.0.1"></a>Introduction</h4>
<!--l. 7--><p class="noindent" >In this Chapter, we will work through an ontology describing a family. This
ontology is freely borrowed from the <a 
href="https://www.w3.org/TR/owl2-primer/" >OWL Primer</a>, but turned into Tawny-OWL
syntax. The point of this ontology is not to build a good model, but to use pretty
much every feature of OWL, so that they can be described. By the time that
we have finished this Chapter, we will have worked through everything
that OWL can do. Later chapters will be on Tawny-OWL functionality
alone.
<!--l. 17--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">8.1   </span> <a 
 id="x1-490008.1"></a>The Ontology</h3>
<!--l. 20--><p class="noindent" >We start with a namespace declaration. As normal, we require <code class="language-tawny">tawny.owl</code>.
However, the rest of the form is a bit different. The first is that we also require
<code class="language-tawny">tawny.english</code>. This package is a little unusual in that it brings no new
functionality; it does, however, bring some new names. As we have seen,
<code class="language-tawny">tawny.owl</code> contains quite a few names that start with the string &#8220;owl&#8221; &#8211; so,
<code class="language-tawny">owl-class</code>, <code class="language-tawny">owl-not</code> and so forth. The reason for this is that the simpler names
&#8220;class&#8221; and &#8220;not&#8221; are already used by Clojure to do something else, with a
different set of functions. <code class="language-tawny">tawny.english</code> provides these shorter names.
But this comes with a slight cost; we much make sure that the Clojure
functions no longer use these names, or Clojure will complain. In this
case, we take the simple route and just remove all the default Clojure
functions with <code class="language-tawny">refer-clojure</code> &#8211; this allows us to say exactly which Clojure
functions we wish to support &#8211; in this case <code class="language-tawny">:only&#x00A0;[]</code> or only the empty list,
i&#x0117;&#x1E45;othing.
<!--l. 37--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(ns take.wing.family
  (:refer-clojure :only [])
  (:require [tawny.owl :refer :all]
             [tawny.english :refer :all]))
</code></pre>
<!--l. 44--><p class="indent" >   Next, we define the <code class="language-tawny">family</code> ontology. This ontology is slightly different from
the ones that we have created before in that the IRI ends with a <code class="language-tawny">/</code>. Tawny-OWL
copes with this straight-forwardly; the IRIs of all entities will be formed after the
slash.
<!--l. 49--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defontology family
  :iri "http://example.com/owl/family/")
</code></pre>
<!--l. 54--><p class="indent" >   We start off with something new. Previously, we introduced <span 
class="cmti-10x-x-109">object </span>properties
(see Section&#x00A0;<a 
href="#x1-340005.5">5.5<!--tex4ht:ref: sec:properties --></a>). These properties describe a relationship between two individuals;
but OWL also supports another form of property which is the <span 
class="cmti-10x-x-109">data property</span>. This
draws a relationship between an individual and some piece of data &#8211; a string, a
number or so on. At first sight, it looks a bit similar to an annotation such as a
label or a comment, but it is different because we can reason about it.
In this case, we define a new property the for the National Insurance
number<span class="footnote-mark"><a 
href="#fn1x9" id="fn1x9-bk"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-49001f1"></a>.
<!--l. 68--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defdproperty hasNIN
  :comment "A National Insurance Number")
</code></pre>
<!--l. 73--><p class="indent" >   We next define two classes: <code class="language-tawny">Human</code> and <code class="language-tawny">Person</code>. We define these as equivalent.
They are the same set of individuals and to be a <code class="language-tawny">Person</code> is to be a <code class="language-tawny">Human</code>. We
can look at these two as being synonyms, although there are, perhaps,
better ways of defining synonyms using annotations which we investigate
later.
<!--l. 79--><p class="indent" >   The <code class="language-tawny">Person</code> class has two other additions. It uses an annotation frame, with
two annotations &#8211; one a comment and the other a label with a language specified
(Italian &#8211; which probably we should have added to Pizza!). Finally, <code class="language-tawny">Person</code> has a
<code class="language-tawny">:haskey</code> frame. This states that the national insurance number uniquely identifies
a person.
<!--l. 85--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-equivalent
 (defclass Human)

 (defclass Person
   :annotation (comment "Represents the set of all people.")
   (label "Personna" "it")
   :haskey hasNIN))
</code></pre>
<!--l. 96--><p class="indent" >   Next we move to another datatype property. As with object properties it is
possible to add a domain and range to the property. In the case of domain, this
states that the individual with a <code class="language-tawny">hasAge</code> property must be a <code class="language-tawny">Person</code>. As this is a
datatype property the range is not an individual but a value which in this case
must be a non-negative integer. Finally, you can have only one age, hence the
property is functional.
<!--l. 104--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defdproperty hasAge
  :domain Person
  :range :XSD_NON_NEGATIVE_INTEGER
  :characteristic :functional)
</code></pre>
<!--l. 111--><p class="indent" >   Next, we define two classes, <code class="language-tawny">Man</code> and <code class="language-tawny">Woman</code> both of which are subclasses of
<code class="language-tawny">Person</code>. These do not cover the superclasses (as there are many people who are
neither a man nor a woman). Additionally, though, we add a new type of
annotation; we want to annotate the statement that a <code class="language-tawny">Woman</code> is a <code class="language-tawny">Person</code>. This is
neither a comment on <code class="language-tawny">Woman</code> nor on <code class="language-tawny">Person</code> but strictly on the relationship
between the two &#8211; or in OWL terms we are annotating the axiom. We achieve
this using the <code class="language-tawny">annotate</code> function.
<!--l. 120--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint
 (defclass Man
   :super
   (annotate Person
              (comment "States that every man is a person")))
 (defclass Woman
   :super
   (annotate Person
              (comment "States that every woman in a person"))))
</code></pre>
<!--l. 132--><p class="indent" >   We next define a set of properties that demonstrate two new characteristics
that is <code class="language-tawny">:symmetric</code> and <code class="language-tawny">:asymmetric</code>. The <code class="language-tawny">hasSpouse</code> property is declare symmetric
because it can be declared in either direction: if <code class="language-tawny">a</code> is the spouse of <code class="language-tawny">b</code> then <code class="language-tawny">b</code> is also
the spouse of <code class="language-tawny">a</code>. This is distinctly not true of <code class="language-tawny">hasChild</code> &#8211; in fact, it can never be
true, so we declare this property asymmetric.
<!--l. 139--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-inverse
 (defoproperty hasParent)
 (defoproperty hasChild
   :characteristic :asymmetric))

(defoproperty hasSpouse
  :characteristic :symmetric
  :disjoint hasParent)
</code></pre>
<!--l. 150--><p class="indent" >   The OWL Primer next defines <code class="language-tawny">hasWife</code> with the following domain and range
constraints.
<!--l. 153--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasWife
  :super hasSpouse
  :domain Man :range Woman)
</code></pre>
<!--l. 159--><p class="indent" >   Interestingly, in the relatively short time since the OWL primer ontology was
first developed, this statement is now a poor reflection of the real world, so we
make this, more limited, statement instead.
<!--l. 163--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasWife
  :super hasSpouse
  :range Woman)
</code></pre>
<!--l. 169--><p class="indent" >   Next, we model <code class="language-tawny">hasHusband</code> slightly differently, but stating both that it and
its inverse are <code class="language-tawny">:functional</code>. This does not require that we explictly define the
inverse &#8211; whether it is or not, it will now be functional. Again, there are some
limitations to this modelling; by declaring <code class="language-tawny">hasHusband</code> function we limit this
ontology to describing only a point in time rather than a period of time. This is
not unreasonable, since OWL lacks the ability to express &#8220;one at a time&#8221;; also,
the ontology makes the same assumption elsewhere (with <code class="language-tawny">hasAge</code> for
instance).
<!--l. 179--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasHusband
  :super hasSpouse
  :range Man
  :characteristic :functional
  :inversefunctional)
</code></pre>
<!--l. 187--><p class="indent" >   The <code class="language-tawny">hasRelative</code> property has yet another characteristic which is reflexivity &#8211;
if you are my relative, then I am your relative. Again, this is not and cannot be
true of <code class="language-tawny">parentOf</code>, so we declare this <code class="language-tawny">:irreflexive</code>.
<!--l. 192--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasRelative
  :characteristic :reflexive)

(defoproperty parentOf
  :characteristic :irreflexive)
</code></pre>
<!--l. 200--><p class="indent" >   And, finally, we move onto the last characteristic which is transitivity. Your
ancestors ancestor is your ancestor also.
<!--l. 203--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasAncestor
  :characteristic :transitive)
</code></pre>
<!--l. 208--><p class="indent" >   The next two properties are nice and simple, expressiving father and
brotherhood.
<!--l. 211--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasFather
  :super hasParent)

(defoproperty hasBrother)
</code></pre>
<!--l. 218--><p class="indent" >   We can also define subchain properties. In this case, this says that a
property is the subproperty of two other links. So, for example, the parent of
a parent is also the grandparent. In this case, both properties are the
same, but we can also express more complex notions such as <code class="language-tawny">hasUncle</code>
with is the brother of my father. A subchain can contain any number of
properties not just the two given here. We also show two different syntaxes:
the first is simpler, while the second encloses the subchain in <code class="language-tawny">[]</code>. The
advantage of the second syntax is that it allows more than one subchain to be
expressed.
<!--l. 228--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty hasGrandparent
  :subchain hasParent hasParent)

(defoproperty hasUncle
  :subchain [hasFather hasBrother])
</code></pre>
<!--l. 236--><p class="indent" >   Next we define a few more properties that we will use later on, and make
them disjoint.
<!--l. 239--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint
 (defoproperty hasDaughter
    :super hasChild)
 (defoproperty hasSon
    :super hasChild))
</code></pre>
<!--l. 247--><p class="indent" >   We now start to add more detail to some classes. <code class="language-tawny">Parent</code> is simple enough to
define as someone with a child. Actually, we are less specific than this and just
say &#8220;something&#8221; with a child.
<!--l. 251--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Parent
  :equivalent (some hasChild Person))
</code></pre>
<!--l. 256--><p class="indent" >   Now, we split the world of people up a bit further. The OWL Primer does
this is in a slightly erratic way. First it defines three classes <code class="language-tawny">YoungChild</code>, <code class="language-tawny">Father</code>
and <code class="language-tawny">Mother</code> as disjoint. This is a strange way to model things for a couple of
reasons. Firstly, it does not define what young means but it is possible to be a
parent at an age that most people would describe as a young child. Secondly,
being a young child is a developmental stage, while being a father or mother
stems from an action in the past; so while mother and child might happen to be
disjoint, they are not naturally so; rather their superclasses should be
declared disjoint. Consider a simpler example: elephants and cars are
also disjoint, but if we build an ontology it would be better to say that
animate and inanimate things are disjoint, and have elephants and cars
inherit this property. This form of ontology building is known as ontology
<span 
class="cmti-10x-x-109">normalisation</span>&#x00A0;<span class="cite">[<span 
class="cmbx-10x-x-109">?</span>]</span>.
<!--l. 271--><p class="indent" >   The second issue is the strange asymmetry between the definitions for <code class="language-tawny">Father</code>
and <code class="language-tawny">Mother</code>.
<!--l. 274--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint
 (defclass YoungChild)

 (defclass Father :super
   (and Man Parent))

 (defclass Mother
   :super Woman
   :equivalent (and Woman Parent)))
</code></pre>
<!--l. 286--><p class="indent" >   Rather than replicate this, in this version of the ontology, we instead make
<code class="language-tawny">YoungChild</code> disjoint with <code class="language-tawny">Woman</code> and <code class="language-tawny">Man</code>, make the definition of <code class="language-tawny">Father</code> and <code class="language-tawny">Mother</code>
symmetrical and covering.
<!--l. 290--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(as-disjoint
 Woman Man
 (defclass YoungChild))

(as-subclasses
 Parent
 :cover :disjoint

 (defclass Mother
   :equivalent (and Woman Parent))

 (defclass Father
   :equivalent (and Man Parent)))
</code></pre>
<!--l. 306--><p class="indent" >   One thing that is often confusing with OWL is that it copes well with missing
knowledge: we need to say the truth, and nothing but the truth; the whole truth,
however, is not so important.
<!--l. 310--><p class="indent" >   So consider this definition of <code class="language-tawny">Grandfather</code>; a man who is a parent. This
definition looks strangely like the definition for <code class="language-tawny">Father</code>. The difference here is that
we are using the <code class="language-tawny">:super</code> frame not <code class="language-tawny">:equivalent</code>; it is necessarily true that
every <code class="language-tawny">Grandfather</code> is a parent (or, if we substitute in the definition of
<code class="language-tawny">Parent</code>, that every <code class="language-tawny">Grandfather</code> has a <code class="language-tawny">Child</code>). But, while being a <code class="language-tawny">Man</code> with a
<code class="language-tawny">Child</code> is sufficient to conclude they are a <code class="language-tawny">Father</code>, they may well not be a
<code class="language-tawny">Grandfather</code>.
<!--l. 319--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Grandfather
  :super (and Man Parent))
</code></pre>
<!--l. 324--><p class="indent" >   The next definition makes use of two new pieces of semantics; we define
<code class="language-tawny">ChildlessPerson</code> to be equivalent to <code class="language-tawny">not&#x00A0;Parent</code>. At the same time, we state
much the same thing, but using an <code class="language-tawny">inverse</code> statement; this returns a property
which is the inverse of the argument; in this case, the property would be
equivalent to <code class="language-tawny">hasChild</code> but there does not need to be a named inverse for this to
work.
<!--l. 331--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass ChildlessPerson
  :equivalent (and Person (not Parent))
  :super (and Person
                   (not
                    (some
                     (inverse hasParent)
                     (thing)))))
</code></pre>
<!--l. 341--><p class="indent" >   Next, we wish to define a <code class="language-tawny">HappyPerson</code> as someone with only happy
children. Because Tawny-OWL has a define before use semantics, we have to
do this in two goes; first, with a <code class="language-tawny">defclass</code> statement, and then using
<code class="language-tawny">refine</code>.
<!--l. 346--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass HappyPerson)
(refine HappyPerson
         :equivalent (only hasChild HappyPerson))
</code></pre>
<!--l. 352--><p class="indent" >   This looks like an odd thing to say; this would mean that a happy
person would have a happy child. But then the happy child would have to
have a happy child also, and their happy child would have to have a
happy child. There are circumstances when this kind of statement would
be fine, but it does not work with children. Actually, though, we have
not say you must have a happy child to be happy; that would look like
this:
<!--l. 360--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(refine HappyPerson
         :equivalent (and (only hasChild HappyPerson)
                           (some hasChild HappyPerson)))
</code></pre>
<!--l. 366--><p class="indent" >   Instead, we have said, if you have children, they must be happy. Or looked at
another way, children can make you miserable, but they cannot make you
happy<span class="footnote-mark"><a 
href="#fn2x9" id="fn2x9-bk"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-49002f2"></a>.
<!--l. 371--><p class="indent" >   Next we move onto annotation properties. We have already seen the built-in
properties, like comment and label. In Chapter&#x00A0;<a 
href="#x1-400006">6<!--tex4ht:ref: cha:highly-patt-ontol --></a>, we used annotations to
represent one and three letter abbreviations for the amino-acids. We do likewise
here, and create a property called <code class="language-tawny">shortname</code> and another called <code class="language-tawny">nickname</code>. For the
latter, we also use the <code class="language-tawny">annotator</code> function to create a new function creating
annotations with this property; this is a fairly convienient way of using
annotations.
<!--l. 380--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defaproperty shortname
  :super label-property)

(defaproperty nickname
  :super label-property)

(def nick (annotator nickname))
</code></pre>
<!--l. 390--><p class="indent" >   Next we add some individuals &#8211; each in this case a person. We create three
individuals. <code class="language-tawny">Mary</code> is asserted to be <code class="language-tawny">Person</code> and a <code class="language-tawny">Woman</code>, while <code class="language-tawny">MaryBrown</code> is asserted
to be the same as <code class="language-tawny">Mary</code>. We do not know anything about <code class="language-tawny">Susan</code>.
<!--l. 395--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defindividual Mary
  :type Person Woman)

(defindividual MaryBrown
  :same Mary)

(defindividual Susan)
</code></pre>
<!--l. 405--><p class="indent" >   With <code class="language-tawny">James</code> we take a slight different approach and define two labels &#8211; one
&#8220;James&#8221; and one a specialism label which is the short name.
<!--l. 408--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defindividual James
  :label "James"
  :annotation (annotation shortname "Jim"))
</code></pre>
<!--l. 414--><p class="indent" >   For <code class="language-tawny">William</code> we want to say a little more &#8211; we add the constraints that over
who his wife and daughter are not.
<!--l. 417--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defindividual William
  :annotation (annotation shortname "Bill")
  :fact
  (not hasWife Mary)
  (not hasDaughter Susan))
</code></pre>
<!--l. 425--><p class="indent" >   Early, we asserted that <code class="language-tawny">Father</code> is a class, but we might also want to make it
an individual &#8211; in this case, of <code class="language-tawny">SocialRole</code>. The trick, called <span 
class="cmti-10x-x-109">punning </span>to doing
this in OWL is to create two entities with the same name, or IRI. We
achieve this in Tawny-OWL by passing an IRI in place of the name; if we
want to be able to refer to this entity later, we also need to assign it to
variable.
<!--l. 432--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass SocialRole)
(def iFather
  (individual (.getIRI Father)
               :type SocialRole))
</code></pre>
<!--l. 439--><p class="indent" >   We have little positive to say about <code class="language-tawny">Jack</code> &#8211; but several negative things. He is
not a parent nor 53 years old. However, we do use the <code class="language-tawny">nick</code> annotator
function that we created earlier to give him the unfortunate nick name &#8220;The
Cat&#8221;.
<!--l. 444--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defindividual Jack
  :annotation (nick "The Cat")
  :type Person (not Parent)
  :fact (not hasAge (literal 53)))
</code></pre>
<!--l. 451--><p class="indent" >   <code class="language-tawny">John</code> on the other hand, we have some useful things to say; in fact, we say lots
of things about his children. We say that he at least 2 children who are parents,
at most 4 children who are parents and exactly 3 children who are parents &#8211; all a
bit duplicative, but it showns the range of <span 
class="cmti-10x-x-109">cardinality </span>constraints that it is
possible to make. In addition, we say that he has 5 children in total, so we would
assume this means 2 who are not parents. He is not the same as <code class="language-tawny">William</code>, has a
wife <code class="language-tawny">Mary</code> and is 51.
<!--l. 460--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defindividual John
  :type Father
  (at-least 2 hasChild Parent)
  (exactly 3 hasChild Parent)
  (exactly 5 hasChild)
  (at-most 4 hasChild Parent)
  :different William
  :fact
  (is hasWife Mary)
  (is hasAge 51))
</code></pre>
<!--l. 473--><p class="indent" >   Mostly, in OWL, classes are defined in terms of classes, but it is possible to
define a class in terms of an individual with the <code class="language-tawny">has-value</code> constructor, in this
case, <code class="language-tawny">JohnsChildren</code>.
<!--l. 477--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass JohnsChildren
  :equivalent (has-value hasParent John))
</code></pre>
<!--l. 482--><p class="indent" >   There is also a specialised relationship to describe tthe relationship an
individuals of a class have with themselves using <code class="language-tawny">has-self</code>. This definition
of <code class="language-tawny">NarcisiticPerson</code> is not the same as either <code class="language-tawny">some&#x00A0;loves&#x00A0;Person</code> nor
<code class="language-tawny">(only&#x00A0;loves&#x00A0;Person)</code> &#8211; since this would be a person who loves a person, which
could be themselves, but does not have to be.
<!--l. 489--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defoproperty loves)

(defclass NarcisticPerson
  :equivalent (has-self loves))
</code></pre>
<!--l. 496--><p class="indent" >   Our next definition, of <code class="language-tawny">Orphan</code> makes use of an unnamed inverse of <code class="language-tawny">hasChild</code>.
This is semantically equivalent to using <code class="language-tawny">hasParent</code>, although the named inverse
property does not need to exist as here.
<!--l. 500--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Dead)
(defclass Orphan
  :equivalent (only (inverse hasChild) Dead))
</code></pre>
<!--l. 506--><p class="indent" >   We touched earlier of datatype properties which describe a relationship
between an individual and a piece of data; it is also possible to be restrictions on
what that data can be. OWL has a large number of built-in data types,
but it is possible to define arbitrary new ones. Tawny-OWL provides
several syntaxes for going this &#8211; we use the long hand syntax first, to
define <code class="language-tawny">personAge</code> which is, rather arbitrarily, an integer between 0 and
150.
<!--l. 514--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defdatatype personAge
  :equivalent (min-max-inc 0 150))
</code></pre>
<!--l. 519--><p class="indent" >   The <code class="language-tawny">span</code> macro provides a syntactic variant of <code class="language-tawny">min-mix-inc</code> and other related
functions. We use this to define the age of a child as between 0 and 17, while we
define the age of an adult using <code class="language-tawny">and</code> and <code class="language-tawny">not</code>. These functions are the same
functions we used earlier for defining logic restrictions, but they work with
datatypes too.
<!--l. 525--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defdatatype childAge
  :equivalent (span &gt;=&lt; 0 17))

(defdatatype adultAge
  :equivalent (and personAge (not childAge)))
</code></pre>
<!--l. 533--><p class="indent" >   We can define <code class="language-tawny">toddlerAge</code> just by describing all the possibilities as there are
only two of them.
<!--l. 536--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defdatatype toddlerAge
  :equivalent (oneof 1 2))
</code></pre>
<!--l. 541--><p class="indent" >   Again, <code class="language-tawny">oneof</code> is overloaded and can be used either with datatype properties,
data values (such as 1 and 2) or, as here, with individuals.
<!--l. 545--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass MyBirthdayGuests
  :equivalent (oneof William John Mary))
</code></pre>
<!--l. 550--><p class="indent" >   We define a teenage as having an age between 13 and 19. We could also have
defined <code class="language-tawny">teenAge</code> as a datatype and then used it here. Instead of either <code class="language-tawny">min-max</code>
or the <code class="language-tawny">span</code> syntax, here we have used the <code class="language-tawny">&#x003E;&#x003C;</code> syntax which is found in
<code class="language-tawny">tawny.english</code>; this is the simplest syntax however some of the datatype
functions (<code class="language-tawny">&#x003C;</code> and <code class="language-tawny">&#x003E;</code>) also have equivalents in <code class="language-tawny">clojure.core</code>; in this case we have
explicitly excluded the <code class="language-tawny">clojure.core</code> functions, otherwise, we would have a
nameclash.
<!--l. 558--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Teenager
  :super (some hasAge (&gt;&lt; 13 19)))
</code></pre>
<!--l. 563--><p class="indent" >   Finally, we define a class and individual.
<!--l. 565--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(defclass Female)
(defindividual Meg :type Female)
</code></pre>
<!--l. 570--><p class="indent" >   We define a <a 
href="http://ontogenesis.knowledgeblog.org/1288" >GCI</a> or General Concept Inclusion, which defines a general rule
relating two different class expressions. This allows us to draw a relationship
between two unnamed classes. In this case, we are saying that one of <code class="language-tawny">Mary</code>,
<code class="language-tawny">William</code> or <code class="language-tawny">Meg</code> is a parent with at most one daughter.
<!--l. 576--><p class="indent" >   Despite the name &#8220;General&#8221;, GCIs have a relatively limited range of
applications; most ontologies do not make use of them and can use the other
features of OWL. But they are supported by OWL and, therefore, also supported
by Tawny-OWL.
<!--l. 581--><p class="noindent" >
                                                                     

                                                                     
<pre><code class="language-tawny">(gci
 (and Parent
       (at-most 1 hasChild)
       (only hasChild Female))
 (and (oneof Mary, William, Meg) Female))
</code></pre>
   <h3 class="sectionHead"><span class="titlemark">8.2   </span> <a 
 id="x1-500008.2"></a>Recap</h3>
<!--l. 593--><p class="noindent" >In this chapter, we have described the Family ontology and with it used to
describe every construct that the OWL language provides.
                                                                     

                                                                     
                                                                     

                                                                     
                                                                     

                                                                     
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;9</span><br /><a 
 id="x1-510009"></a>Conclusions</h2>
<!--l. 4--><p class="noindent" >In this book, we have introduced Tawny-OWL as well as covering some of
the background for OWL and Ontology building in general. None of
these topics are simple ones and, of course, there is more to say about
both.
<!--l. 9--><p class="indent" >   However, taken together these tools provide a powerful environment for the
describing the world around us in a computationally amenable way. This can be
used to structure, query and order knowledge about the world. Perhaps it is
presumptuous, but with luck these somewhat prosaic capabilities to allow us to
understand the world a little better.
                                                                     

                                                                     
   <div class="footnotes"><!--l. 49--><p class="indent" >     <span class="footnote-mark"><a 
href="#fn1x3-bk" id="fn1x3"><sup class="textsuperscript">1</sup></a></span><span 
class="cmr-9">One of the joys of ontology development is that the ontology development community is</span>
<span 
class="cmr-9">rich with arguments about the correct way to model things. Even, with relatively simple models</span>
<span 
class="cmr-9">it is easy to hit these arguments and, in fact, we have done so here already. There is a strong</span>
<span 
class="cmr-9">argument to say that </span><code class="language-tawny">TakeWing</code> <span 
class="cmr-9">is actually an instance of </span><code class="language-tawny">Book</code> <span 
class="cmr-9">rather than a subclass, because</span>
<span 
class="cmr-9">there is only one of them. Or, that </span><code class="language-tawny">TakeWing</code> <span 
class="cmr-9">is a class because there are many copies of</span>
<code class="language-tawny">TakeWing</code><span 
class="cmr-9">. Or, that it&#8217;s a metaclass, because sometimes it operates like a class and sometimes</span>
<span 
class="cmr-9">an individual. In this book, we try to touch on these arguments, but not get weighed down by</span>
<span 
class="cmr-9">them</span><!--l. 64--><p class="indent" > <span class="footnote-mark"><a 
href="#fn2x3-bk" id="fn2x3"><sup class="textsuperscript">2</sup></a></span><span 
class="cmr-9">Strictly, an </span><span 
class="cmti-9">object property</span><span 
class="cmr-9">, hence the &#8220;o&#8221;. We describe these more fully later</span>
<!--l. 201--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn3x3-bk" id="fn3x3"><sup class="textsuperscript">3</sup></a></span><span 
class="cmr-9">Sort of. In other environments, we have argued that Tawny-OWL is an textual</span>
<span 
class="cmr-9">application rather than a programmatic library. In reality, it is a bit of both: it is a library which</span>
<span 
class="cmr-9">is designed with development rather than manipulation of ontologies as its primary purpose. For</span>
<span 
class="cmr-9">the latter, we would have done things rather differently.</span>
<!--l. 12--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn1x4-bk" id="fn1x4"><sup class="textsuperscript">1</sup></a></span><span 
class="cmr-9">W3C is the body that would define standards for the Web, if it made standards. Except</span>
<span 
class="cmr-9">that it does not; it just releases recommendations.</span>
<!--l. 20--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn2x4-bk" id="fn2x4"><sup class="textsuperscript">2</sup></a></span><span 
class="cmr-9">Mostly because if I touched on it more heavily, I&#8217;d probably get it wrong</span>
<!--l. 51--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn3x4-bk" id="fn3x4"><sup class="textsuperscript">3</sup></a></span><span 
class="cmr-9">Like &#8220;object&#8221; which also has an ontological meaning.</span>
<!--l. 55--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn4x4-bk" id="fn4x4"><sup class="textsuperscript">4</sup></a></span><span 
class="cmr-9">Although, some individuals are anonymous. We will discuss more on the form of</span>
<span 
class="cmr-9">identifiers later.</span><!--l. 66--><p class="indent" > <span class="footnote-mark"><a 
href="#fn5x4-bk" id="fn5x4"><sup class="textsuperscript">5</sup></a></span><span 
class="cmr-9">Roughly equivalent to properties or attributes in OO terminology</span>
<!--l. 70--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn6x4-bk" id="fn6x4"><sup class="textsuperscript">6</sup></a></span><span 
class="cmr-9">This is less restrictive than it sounds.</span><!--l. 107--><p class="indent" > <span class="footnote-mark"><a 
href="#fn7x4-bk" id="fn7x4"><sup class="textsuperscript">7</sup></a></span><span 
class="cmr-9">IRIs are not the same thing as URIs,which are not the same thing as URLs. But the</span>
<span 
class="cmr-9">differences between them are relative unimportant here.</span>
<!--l. 37--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn1x6-bk" id="fn1x6"><sup class="textsuperscript">1</sup></a></span><span 
class="cmr-9">The analogy between a pizza menu and an ontology is not perfect. With</span>
<span 
class="cmr-9">pizza, people are generally happy with the classes (i.e. the menu) and start arguing</span>
<span 
class="cmr-9">once about the individuals (i.e. the bill); with ontologies it tends to be the other way</span>
<span 
class="cmr-9">around</span><!--l. 52--><p class="indent" > <span class="footnote-mark"><a 
href="#fn2x6-bk" id="fn2x6"><sup class="textsuperscript">2</sup></a></span><span 
class="cmr-9">The name of this directory is not functional important and be changed at</span>
<span 
class="cmr-9">will</span><!--l. 108--><p class="indent" > <span class="footnote-mark"><a 
href="#fn3x6-bk" id="fn3x6"><sup class="textsuperscript">3</sup></a></span><span 
class="cmr-9">In Tawny-OWL, this requirement is weakened &#8211; if you do not put an IRI, Tawny-OWL</span>
<span 
class="cmr-9">invents one for you. This is okay if you are experiments, but should be changed when you</span>
<span 
class="cmr-9">publish an ontology.</span>
<!--l. 175--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn4x6-bk" id="fn4x6"><sup class="textsuperscript">4</sup></a></span><span 
class="cmr-9">In this ontology, we use a naming scheme using CamelCase, upper case names for</span>
<span 
class="cmr-9">classes and, later, lower case properties. As with many parts of ontology development, opinions</span>
<span 
class="cmr-9">differ as to whether this is good. With Tawny-OWL it has the fortuitous advantage that it</span>
<span 
class="cmr-9">syntax highlights nicely, because it looks like Java class names.</span>
<!--l. 292--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn5x6-bk" id="fn5x6"><sup class="textsuperscript">5</sup></a></span><span 
class="cmr-9">For those from an OWL background, you may have noticed that &#8220;covering&#8221; is not part</span>
<span 
class="cmr-9">of the OWL standard; in fact, it&#8217;s a pattern that is frequently used. The semantics are that</span>
<code class="language-tawny">PizzaComponent</code> <span 
class="cmr-9">is equivalent to </span><code class="language-tawny">PizzaBase</code> <span 
class="cmr-9">or </span><code class="language-tawny">PizzaTopping</code>
<!--l. 320--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn6x6-bk" id="fn6x6"><sup class="textsuperscript">6</sup></a></span><span 
class="cmr-9">Actually, two </span><span 
class="cmti-9">object </span><span 
class="cmr-9">properties, hence </span><code class="language-tawny">defoproperty</code><span 
class="cmr-9">. We can also define </span><span 
class="cmti-9">data </span><span 
class="cmr-9">properties,</span>
<span 
class="cmr-9">which we will see later</span><!--l. 352--><p class="indent" > <span class="footnote-mark"><a 
href="#fn7x6-bk" id="fn7x6"><sup class="textsuperscript">7</sup></a></span><span 
class="cmr-9">We will see examples of the opposite also &#8212; statements which are stronger in OWL</span>
<span 
class="cmr-9">than the intuitive interpretation</span>
<!--l. 401--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn8x6-bk" id="fn8x6"><sup class="textsuperscript">8</sup></a></span><span 
class="cmr-9">For example, we leave open the option of a pizza base with nutella on it; it&#8217;s not clear</span>
<span 
class="cmr-9">whether this is a pizza or not, but if we did decide one way or another, it would be possible to</span>
<span 
class="cmr-9">describe this clearly and explicitly in OWL.</span>
<!--l. 553--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn9x6-bk" id="fn9x6"><sup class="textsuperscript">9</sup></a></span><span 
class="cmr-9">Except to logicians, obviously, to whom it all makes perfect sense.</span>
<!--l. 558--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn10x6-bk" id="fn10x6"><sup class="textsuperscript">10</sup></a></span><span 
class="cmr-9">Pizza names are, sadly, not standardized between countries or resturants, so I&#8217;ve picked</span>
<span 
class="cmr-9">on which is quite widely known. Apologies to any Italian readers for this and any other culinary</span>
<span 
class="cmr-9">disasters which this book implies really are pizza.</span>
<!--l. 138--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn1x8-bk" id="fn1x8"><sup class="textsuperscript">1</sup></a></span><span 
class="cmr-9">Many IDEs have mechanisms for running </span><code class="language-tawny">macroexpand&minus;1</code> <span 
class="cmr-9">and printing the output</span>
<span 
class="cmr-9">nicely.</span>
<!--l. 66--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn1x9-bk" id="fn1x9"><sup class="textsuperscript">1</sup></a></span><span 
class="cmr-9">The OWL Primer from which I borrowed this ontology has a data property called</span>
<span 
class="cmr-9">hasSSN or social security number. But I don&#8217;t have one of these which reflects the dangers of</span>
<span 
class="cmr-9">over-generalisation in ontology building</span>
<!--l. 369--><p class="indent" >      <span class="footnote-mark"><a 
href="#fn2x9-bk" id="fn2x9"><sup class="textsuperscript">2</sup></a></span><span 
class="cmr-9">I never claimed that this ontology was a good reflection of the real world</span>          </div>
 
</body></html> 

                                                                     


